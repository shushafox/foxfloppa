[gd_scene load_steps=27 format=4 uid="uid://c3eej3xyhm2xt"]

[ext_resource type="Script" path="res://scripts/Levels/level1.gd" id="1_cy0xy"]
[ext_resource type="Texture2D" uid="uid://ce4wh6oqwcfgx" path="res://assets/plains.png" id="4_5728d"]
[ext_resource type="Texture2D" uid="uid://b3bbva2ayfbrm" path="res://assets/fences.png" id="5_4trq1"]
[ext_resource type="Texture2D" uid="uid://c25eog5myang0" path="res://assets/outline.png" id="6_kwc70"]
[ext_resource type="PackedScene" uid="uid://bm8now0ny2t7x" path="res://scenes/UI/UI.tscn" id="8_yw6rv"]
[ext_resource type="PackedScene" uid="uid://c1q2v801ir7ng" path="res://scenes/Templates/ObjTemplate.tscn" id="9_7ui60"]
[ext_resource type="Texture2D" uid="uid://bgsq3dtm88xcc" path="res://assets/outline(le evil).png" id="11_6mk6w"]
[ext_resource type="PackedScene" uid="uid://bgiboq2uf7h68" path="res://scenes/Triggers/CombarTrigger.tscn" id="11_gtgde"]
[ext_resource type="PackedScene" uid="uid://bbrdrx30yyqfl" path="res://scenes/Triggers/LevelChangeTrigger.tscn" id="11_itbd5"]
[ext_resource type="PackedScene" uid="uid://gf61d1durb0j" path="res://scenes/player.tscn" id="12_6myqq"]
[ext_resource type="PackedScene" uid="uid://oniaupnu0kcv" path="res://scenes/Triggers/DialogueTrigger.tscn" id="12_x6p1d"]
[ext_resource type="PackedScene" uid="uid://bkk6h2os2fp6k" path="res://scenes/Npcs/Corvi.tscn" id="13_vtoc5"]
[ext_resource type="PackedScene" uid="uid://byyxxxfsu3rmg" path="res://scenes/Npcs/Amogus.tscn" id="14_k74xa"]
[ext_resource type="Texture2D" uid="uid://cxfyhqlk8blek" path="res://assets/Roi/Roi_32.png" id="15_kxo26"]
[ext_resource type="Texture2D" uid="uid://b00d82j8j5r8f" path="res://assets/Roi/Roi_Portrait.png" id="16_7kn55"]

[sub_resource type="GDScript" id="GDScript_oxieu"]
script/source = "@tool
@icon(\"res://addons/phantom_camera/icons/phantom_camera_2d.svg\")
class_name PhantomCamera2D
extends Node2D

## Controls a scene's [Camera2D] and applies logic to it.
##
## The scene's [param Camera2D] will follow the position of the
## [param PhantomCamera2D] with the highest priority.
## Each instance can have different positional and rotational logic applied
## to them.

#region Constants

const _constants := preload(\"res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_constants.gd\")

#endregion

#region Signals

## Emitted when the [param PhantomCamera2D] becomes active.
signal became_active

## Emitted when the [param PhantomCamera2D] becomes inactive.
signal became_inactive

## Emitted when [member follow_target] changes.
signal follow_target_changed

## Emitted when dead zones changes.[br]
## [b]Note:[/b] Only applicable in [param Framed] [enum FollowMode].
signal dead_zone_changed

## Emitted when a target touches the edge of the dead zone in [param Framed] [enum FollowMode].
signal dead_zone_reached(side: Vector2)

## Emitted when the [param Camera2D] starts to tween to another [param PhantomCamera2D].
signal tween_started

## Emitted when the [param Camera2D] is to tweening towards another [param PhantomCamera2D].
signal is_tweening

## Emitted when the tween is interrupted due to another [param PhantomCamera2D]
## becoming active. The argument is the [param PhantomCamera2D] that interrupted
## the tween.
signal tween_interrupted(pcam_2d: PhantomCamera2D)

## Emitted when the [param Camera2D] completes its tween to the
## [param PhantomCamera2D].
signal tween_completed

## Emitted when Noise should be applied to the Camera2D.
signal noise_emitted(noise_output: Transform2D)

signal physics_target_changed

#endregion

#region Enums

## Determines the positional logic for a given [param PhantomCamera2D]
## [br][br]
## The different modes have different functionalities and purposes, so choosing
## the correct one depends on what each [param PhantomCamera2D] is meant to do.
enum FollowMode {
	NONE 			= 0, ## Default - No follow logic is applied.
	GLUED 			= 1, ## Sticks to its target.
	SIMPLE 			= 2, ## Follows its target with an optional offset.
	GROUP 			= 3, ## Follows multiple targets with option to dynamically reframe itself.
	PATH 			= 4, ## Follows a target while being positionally confined to a [Path2D] node.
	FRAMED 			= 5, ## Applies a dead zone on the frame and only follows its target when it tries to leave it.
}

## Determines how often an inactive [param PhantomCamera2D] should update
## its positional and rotational values. This is meant to reduce the amount
## of calculations inactive [param PhantomCamera2D] are doing when idling to
## improve performance.
enum InactiveUpdateMode {
	ALWAYS, ## Always updates the [param PhantomCamera2D], even when it's inactive.
	NEVER, ## Never updates the [param PhantomCamera2D] when it's inactive. Reduces the amount of computational resources when inactive.
#	EXPONENTIALLY,
}

enum FollowLockAxis {
	NONE    = 0,
	X 		= 1,
	Y 		= 2,
	XY		= 3,
}

#endregion

#region Exported Properties

## To quickly preview a [param PhantomCamera2D] without adjusting its
## [member priority], this property allows the selected PCam to ignore the
## Priority system altogether and forcefully become the active one. It's
## partly designed to work within the Viewfinder, and will be disabled when
## running a build export of the game.
@export var priority_override: bool = false:
	set(value):
		if Engine.is_editor_hint() and _has_valid_pcam_owner():
			if value == true:
				priority_override = value
				get_pcam_host_owner().pcam_priority_override(self)
			else:
				priority_override = value
				get_pcam_host_owner().pcam_priority_updated(self)
				get_pcam_host_owner().pcam_priority_override_disabled()
	get:
		return priority_override

## It defines which [param PhantomCamera2D] a scene's [param Camera2D] should
## be corresponding with and be attached to. This is decided by the PCam with
## the highest [param Priority].
## [br][br]
## Changing [param Priority] will send an event to the scene's
## [PhantomCameraHost], which will then determine whether if the
## [param Priority] value is greater than or equal to the currently
## highest [param PhantomCamera2D]'s in the scene. The [param PhantomCamera2D]
## with the highest value will then reattach the [param Camera2D] accordingly.
@export var priority: int = 0:
	set = set_priority,
	get = get_priority

## Determines the positional logic for a given [param PhantomCamera2D].
## The different modes have different functionalities and purposes, so
## choosing the correct one depends on what each [param PhantomCamera2D]
## is meant to do.
@export var follow_mode: FollowMode = FollowMode.NONE:
	set(value):
		follow_mode = value

		if follow_mode == FollowMode.NONE:
			_should_follow = false
			top_level = false
			_is_parents_physics()
			notify_property_list_changed()
			return

		match follow_mode:
			FollowMode.PATH:
				if is_instance_valid(follow_path):
					_should_follow_checker()
			FollowMode.GROUP:
				_follow_targets_size_check()
			_:
				_should_follow_checker()

		if follow_mode == FollowMode.FRAMED:
			if _follow_framed_initial_set and follow_target:
				_follow_framed_initial_set = false
				dead_zone_changed.connect(_on_dead_zone_changed)
		else:
			if dead_zone_changed.is_connected(_on_dead_zone_changed):
				dead_zone_changed.disconnect(_on_dead_zone_changed)

		top_level = true
		notify_property_list_changed()
	get:
		return follow_mode

## Determines which target should be followed.
## The [param Camera2D] will follow the position of the Follow Target
## based on the [member follow_mode] type and its parameters.
@export var follow_target: Node2D = null:
	set = set_follow_target,
	get = get_follow_target

### Defines the targets that the [param PhantomCamera2D] should be following.
@export var follow_targets: Array[Node2D] = []:
	set = set_follow_targets,
	get = get_follow_targets

## Determines the [Path2D] the [param PhantomCamera2D]
## should be bound to.
## The [param PhantomCamera2D] will follow the position of the
## [member follow_target] while sticking to the closest point on this path.
@export var follow_path: Path2D = null:
	set = set_follow_path,
	get = get_follow_path

## Applies a zoom level to the [param PhantomCamera2D], which effectively
## overrides the [param zoom] property of the [param Camera2D] node.
@export var zoom: Vector2 = Vector2.ONE:
	set = set_zoom,
	get = get_zoom

## If enabled, will snap the [param Camera2D] to whole pixels as it moves.
## [br][br]
## This should be particularly useful in pixel art projects,
## where assets should always be aligned to the monitor's pixels to avoid
## unintended stretching.
@export var snap_to_pixel: bool = false:
	set = set_snap_to_pixel,
	get = get_snap_to_pixel

## Enables a preview of what the [PhantomCamera2D] will see in the
## scene. It works identically to how a [param Camera2D] shows which area
## will be visible during runtime. Likewise, this too will be affected by the
## [member zoom] property and the [param viewport_width] and
## [param Viewport Height] defined in the [param Project Settings].
@export var frame_preview: bool = true:
	set(value):
		frame_preview = value
		queue_redraw()
	get:
		return frame_preview

## Defines how the [param PhantomCamera2D] transition between one another.
## Changing the tween values for a given [param PhantomCamera2D]
## determines how transitioning to that instance will look like.
## This is a resource type that can be either used for one
## [param PhantomCamera] or reused across multiple - both 2D and 3D.
## By default, all [param PhantomCameras] will use a [param linear]
## transition, [param easeInOut] ease with a [param 1s] duration.
@export var tween_resource: PhantomCameraTween = PhantomCameraTween.new():
	set = set_tween_resource,
	get = get_tween_resource

## If enabled, the moment a [param PhantomCamera2D] is instantiated into
## a scene, and has the highest priority, it will perform its tween transition.
## This is most obvious if a [param PhantomCamera2D] has a long duration and
## is attached to a playable character that can be moved the moment a scene
## is loaded. Disabling the [param tween_on_load] property will
## disable this behaviour and skip the tweening entirely when instantiated.
@export var tween_on_load: bool = true:
	set = set_tween_on_load,
	get = get_tween_on_load

## Determines how often an inactive [param PhantomCamera2D] should update
## its positional and rotational values. This is meant to reduce the amount
## of calculations inactive [param PhantomCamera2Ds] are doing when idling
## to improve performance.
@export var inactive_update_mode: InactiveUpdateMode = InactiveUpdateMode.ALWAYS

@export_group(\"Follow Parameters\")
## Offsets the [member follow_target] position.
@export var follow_offset: Vector2 = Vector2.ZERO:
	set = set_follow_offset,
	get = get_follow_offset

## Applies a damping effect on the [param Camera2D]'s movement.
## Leading to heavier / slower camera movement as the targeted node moves around.
## This is useful to avoid sharp and rapid camera movement.
@export var follow_damping: bool = false:
	set = set_follow_damping,
	get = get_follow_damping

## Defines the damping amount. The ideal range should be somewhere between 0-1.[br][br]
## The damping amount can be specified in the individual axis.[br][br]
## [b]Lower value[/b] = faster / sharper camera movement.[br]
## [b]Higher value[/b] = slower / heavier camera movement.
@export var follow_damping_value: Vector2 = Vector2(0.1, 0.1):
	set = set_follow_damping_value,
	get = get_follow_damping_value


## Prevents the [param PhantomCamera2D] from moving in a designated axis.
## This can be enabled or disabled at runtime or from the editor directly.
@export var follow_axis_lock: FollowLockAxis = FollowLockAxis.NONE:
	set = set_lock_axis,
	get = get_lock_axis
var _follow_axis_is_locked: bool = false
var _follow_axis_lock_value: Vector2 = Vector2.ZERO


@export_subgroup(\"Follow Group\")
## Enables the [param PhantomCamera2D] to dynamically zoom in and out based on
## the targets' distances between each other.
## Once enabled, the [param Camera2D] will stay as zoomed in as possible,
## limited by the [member auto_zoom_max] and start zooming out as the targets
## move further apart, limited by the [member auto_zoom_min].
## Note: Enabling this property hides and disables the [member zoom] property
## as this effectively overrides that value.
@export var auto_zoom: bool = false:
	set = set_auto_zoom,
	get = get_auto_zoom
## Sets the param minimum zoom amount, in other words how far away the
## [param Camera2D] can be from scene.[br][br]
## This only works when [member auto_zoom] is enabled.
@export var auto_zoom_min: float = 1:
	set = set_auto_zoom_min,
	get = get_auto_zoom_min

## Sets the maximum zoom amount, in other words how close the [param Camera2D]
## can move towards the scene.[br][br]
## This only works when [member auto_zoom] is enabled.
@export var auto_zoom_max: float = 5:
	set = set_auto_zoom_max,
	get = get_auto_zoom_max
## Determines how close to the edges the targets are allowed to be.
## This is useful to avoid targets being cut off at the edges of the screen.
## [br][br]

## The Vector4 parameter order goes: [param Left] - [param Top] - [param Right]
## - [param Bottom].
@export var auto_zoom_margin: Vector4 = Vector4.ZERO:
	set = set_auto_zoom_margin,
	get = get_auto_zoom_margin

@export_subgroup(\"Dead Zones\")
## Defines the horizontal dead zone area. While the target is within it, the
## [param PhantomCamera2D] will not move in the horizontal axis.
## If the targeted node leaves the horizontal bounds, the
## [param PhantomCamera2D] will follow the target horizontally to keep
## it within bounds.
@export_range(0, 1) var dead_zone_width: float = 0:
	set(value):
		dead_zone_width = value
		dead_zone_changed.emit()
	get:
		return dead_zone_width

## Defines the vertical dead zone area. While the target is within it, the
## [param PhantomCamera2D] will not move in the vertical axis.
## If the targeted node leaves the vertical bounds, the
## [param PhantomCamera2D] will follow the target horizontally to keep
## it within bounds.
@export_range(0, 1) var dead_zone_height: float = 0:
	set(value):
		dead_zone_height = value
		dead_zone_changed.emit()
	get:
		return dead_zone_height

## Enables the [param dead zones] to be visible when running the game from the editor.
## [br]
## [param dead zones] will never be visible in build exports.
@export var show_viewfinder_in_play: bool = false

@export_group(\"Limit\")

## Shows the [param Camera2D]'s built-in limit border.[br]
## The [param PhantomCamera2D] and [param Camera2D] can move around anywhere within it.
@export var draw_limits: bool = false:
	set(value):
		_draw_limits = value
		if Engine.is_editor_hint():
			_draw_camera_2d_limit()
	get:
		return _draw_limits

## Defines the left side of the [param Camera2D] limit.
## The camera will not be able to move past this point.
@export var limit_left: int = -10000000:
	set = set_limit_left,
	get = get_limit_left
## Defines the top side of the [param Camera2D] limit.
## The camera will not be able to move past this point.
@export var limit_top: int = -10000000:
	set = set_limit_top,
	get = get_limit_top
## Defines the right side of the [param Camera2D] limit.
## The camera will not be able to move past this point.
@export var limit_right: int = 10000000:
	set = set_limit_right,
	get = get_limit_right
## Defines the bottom side of the [param Camera2D] limit.
## The camera will not be able to move past this point.
@export var limit_bottom: int = 10000000:
	set = set_limit_bottom,
	get = get_limit_bottom

## Allows for setting either a [TileMap], [TileMapLayer] or [CollisionShape2D] node to
## automatically apply a limit size instead of manually adjusting the Left,
## Top, Right and Left properties.[br][br]
## [b]TileMap / TileMapLayer[/b][br]
## The Limit will update after the [TileSet] of the [TileMap] / [TileMapLayer] has changed.[br]
## [b]Note:[/b] The limit size will only update after closing the TileMap editor
## bottom panel.
## [br][br]
## [b]CollisionShape2D[/b][br]
## The limit will update in realtime as the Shape2D changes its size.
## Note: For performance reasons, resizing the [Shape2D] during runtime will not change the Limits sides.
@export_node_path(\"TileMap\", \"Node2D\", \"CollisionShape2D\") var limit_target: NodePath = NodePath(\"\"):
	set = set_limit_target,
	get = get_limit_target

## Applies an offset to the [TileMap]/[TileMapLayer] Limit or [Shape2D] Limit.
## The values goes from [param Left], [param Top], [param Right]
## and [param Bottom].
@export var limit_margin: Vector4i:
	set = set_limit_margin,
	get = get_limit_margin
#@export var limit_smoothed: bool = false: # TODO - Needs proper support
	#set = set_limit_smoothing,
	#get = get_limit_smoothing

@export_group(\"Noise\")
## Applies a noise, or shake, to a [Camera2D].[br]
## Once set, the noise will run continuously after the tween to the [PhantomCamera2D] is complete.
@export var noise: PhantomCameraNoise2D:
	set = set_noise,
	get = get_noise

## If true, will trigger the noise while in the editor.[br]
## Useful in cases where you want to temporarily disable the noise in the editor without removing
## the resource.[br][br]
## [b]Note:[/b] This property has no effect on runtime behaviour.
@export var _preview_noise: bool = true:
	set(value):
		_preview_noise = value
		if not value:
			_transform_noise = Transform2D()

## Enable a corresponding layer for a [member PhantomCameraNoiseEmitter2D.noise_emitter_layer]
## to make this [PhantomCamera2D] be affect by it.
@export_flags_2d_render var noise_emitter_layer: int:
	set = set_noise_emitter_layer,
	get = get_noise_emitter_layer

#region Private Variables

var _is_active: bool = false

## The [PhantomCameraHost] that owns this [param PhantomCamera2D].
var pcam_host_owner: PhantomCameraHost = null:
	set = set_pcam_host_owner,
	get = get_pcam_host_owner

var _should_follow: bool = false
var _follow_framed_offset: Vector2 = Vector2.ZERO
var _follow_target_physics_based: bool = false
var _physics_interpolation_enabled: bool = false # NOTE - Enable for Godot 4.3 and when PhysicsInterpolationMode bug is resolved

var _has_multiple_follow_targets: bool = false
var _follow_targets_single_target_index: int = 0
var _follow_targets: Array[Node2D]

var _follow_velocity_ref: Vector2 = Vector2.ZERO # Stores and applies the velocity of the movement

var _has_follow_path: bool = false

var _tween_skip: bool = false

## Defines the position of the [member follow_target] within the viewport.[br]
## This is only used for when [member follow_mode] is set to [param Framed].
var _follow_framed_initial_set: bool = false

static var _draw_limits: bool

var _limit_sides: Vector4i
var _limit_sides_default: Vector4i = Vector4i(-10000000, -10000000, 10000000, 10000000)

var _limit_node: Node2D

var _limit_inactive_pcam: bool

var _transform_output: Transform2D
var _transform_noise: Transform2D

var _has_noise_resource: bool = false

# NOTE - Temp solution until Godot has better plugin autoload recognition out-of-the-box.
var _phantom_camera_manager: Node

#endregion

#region Public Variables

var tween_duration: float:
	set = set_tween_duration,
	get = get_tween_duration
var tween_transition: PhantomCameraTween.TransitionType:
	set = set_tween_transition,
	get = get_tween_transition
var tween_ease: PhantomCameraTween.EaseType:
	set = set_tween_ease,
	get = get_tween_ease

var viewport_position: Vector2

#endregion

#region Property Validator

func _validate_property(property: Dictionary) -> void:
	################
	## Follow Target
	################
	if property.name == \"follow_target\":
		if follow_mode == FollowMode.NONE or \\
		follow_mode == FollowMode.GROUP:
			property.usage = PROPERTY_USAGE_NO_EDITOR

	elif property.name == \"follow_path\" and \\
	follow_mode != FollowMode.PATH:
		property.usage = PROPERTY_USAGE_NO_EDITOR


	####################
	## Follow Parameters
	####################
	if follow_mode == FollowMode.NONE:
		match property.name:
			\"follow_offset\", \\
			\"follow_damping\", \\
			\"follow_damping_value\":
				property.usage = PROPERTY_USAGE_NO_EDITOR

	if property.name == \"follow_offset\":
		if follow_mode == FollowMode.PATH or \\
		follow_mode == FollowMode.GLUED:
			property.usage = PROPERTY_USAGE_NO_EDITOR

	if property.name == \"follow_damping_value\" and not follow_damping:
		property.usage = PROPERTY_USAGE_NO_EDITOR

	###############
	## Follow Group
	###############
	if follow_mode != FollowMode.GROUP:
		match property.name:
			\"follow_targets\", \\
			\"auto_zoom\":
				property.usage = PROPERTY_USAGE_NO_EDITOR

	if not auto_zoom or follow_mode != FollowMode.GROUP:
		match property.name:
			\"auto_zoom_min\", \\
			\"auto_zoom_max\", \\
			\"auto_zoom_margin\":
				property.usage = PROPERTY_USAGE_NO_EDITOR

	################
	## Follow Framed
	################
	if not follow_mode == FollowMode.FRAMED:
		match property.name:
			\"dead_zone_width\", \\
			\"dead_zone_height\", \\
			\"show_viewfinder_in_play\":
				property.usage = PROPERTY_USAGE_NO_EDITOR

	#######
	## Zoom
	#######
	if property.name == \"zoom\" and follow_mode == FollowMode.GROUP and auto_zoom:
		property.usage = PROPERTY_USAGE_NO_EDITOR

	########
	## Limit
	########
	if is_instance_valid(_limit_node):
		match property.name:
			\"limit_left\", \\
			\"limit_top\", \\
			\"limit_right\", \\
			\"limit_bottom\":
				property.usage = PROPERTY_USAGE_NO_EDITOR

	if property.name == \"limit_margin\" and not _limit_node:
		property.usage = PROPERTY_USAGE_NO_EDITOR

	################
	## Frame Preview
	################
	if property.name == \"frame_preview\" and _is_active:
		property.usage |= PROPERTY_USAGE_READ_ONLY

#region Private Functions

func _enter_tree() -> void:
	_should_follow_checker()
	if follow_mode == FollowMode.GROUP:
		_follow_targets_size_check()
	elif follow_mode == FollowMode.NONE:
		_is_parents_physics()

	if not visibility_changed.is_connected(_check_visibility):
		visibility_changed.connect(_check_visibility)

	_phantom_camera_manager = get_tree().root.get_node(_constants.PCAM_MANAGER_NODE_NAME)
	_phantom_camera_manager.pcam_added(self)
	update_limit_all_sides()

	if not _phantom_camera_manager.get_phantom_camera_hosts().is_empty():
		set_pcam_host_owner(_phantom_camera_manager.get_phantom_camera_hosts()[0])


func _exit_tree() -> void:
	_phantom_camera_manager.pcam_removed(self)

	if _has_valid_pcam_owner():
		get_pcam_host_owner().pcam_removed_from_scene(self)

	if not follow_mode == FollowMode.GROUP:
		follow_targets = []


func _ready() -> void:
	_transform_output = global_transform
	_phantom_camera_manager.noise_2d_emitted.connect(_noise_emitted)

	if not Engine.is_editor_hint():
		_preview_noise = true

	if follow_mode == FollowMode.GROUP:
		_follow_targets_size_check()


func _process(delta: float) -> void:
	if _follow_target_physics_based or _is_active: return
	process_logic(delta)


func _physics_process(delta: float) -> void:
	if not _follow_target_physics_based or _is_active: return
	process_logic(delta)


func process_logic(delta: float) -> void:
	if _is_active:
		if _has_noise_resource and _preview_noise:
			_transform_noise = noise.get_noise_transform(delta)
			if _transform_noise.get_rotation() != 0:
				push_warning(pcam_host_owner.camera_2d.name, \" has ignore_rotation enabled.\")
	else:
		match inactive_update_mode:
			InactiveUpdateMode.NEVER: return
			InactiveUpdateMode.ALWAYS:
				# Only triggers if limit isn't default
				if _limit_inactive_pcam:
					global_position = _set_limit_clamp_position(global_position)
			# InactiveUpdateMode.EXPONENTIALLY:
			# TODO - Trigger positional updates less frequently as more PCams gets added

	_limit_checker()
#	if not Engine.is_editor_hint(): print(_should_follow)
	if _should_follow:
		_follow(delta)
	else:
		_transform_output = global_transform

	if _follow_axis_is_locked:
		match follow_axis_lock:
			FollowLockAxis.X:
				_transform_output.origin.x = _follow_axis_lock_value.x
			FollowLockAxis.Y:
				_transform_output.origin.y = _follow_axis_lock_value.y
			FollowLockAxis.XY:
				_transform_output.origin.x = _follow_axis_lock_value.x
				_transform_output.origin.y = _follow_axis_lock_value.y


func _limit_checker() -> void:
	## TODO - Needs to see if this can be triggerd only from CollisionShape2D Transform changes
	if not Engine.is_editor_hint(): return
	if draw_limits:
		update_limit_all_sides()


func _follow(delta: float) -> void:
	var follow_position: Vector2
	match follow_mode:
		FollowMode.GLUED:
			follow_position = follow_target.global_position

		FollowMode.SIMPLE:
			follow_position = _target_position_with_offset()

		FollowMode.GROUP:
			if _has_multiple_follow_targets:
				var rect: Rect2 = Rect2(_follow_targets[0].global_position, Vector2.ZERO)
				for target in _follow_targets:
					rect = rect.expand(target.global_position)
				if auto_zoom:
					rect = rect.grow_individual(
						auto_zoom_margin.x,
						auto_zoom_margin.y,
						auto_zoom_margin.z,
						auto_zoom_margin.w
					)

					var screen_size: Vector2 = get_viewport_rect().size
					if rect.size.x > rect.size.y * screen_size.aspect():
						zoom = clamp(screen_size.x / rect.size.x, auto_zoom_min, auto_zoom_max) * Vector2.ONE
					else:
						zoom = clamp(screen_size.y / rect.size.y, auto_zoom_min, auto_zoom_max) * Vector2.ONE
				follow_position = rect.get_center()
			else:
				follow_position = follow_targets[_follow_targets_single_target_index].global_position

		FollowMode.PATH:
			var path_position: Vector2 = follow_path.global_position

			follow_position = \\
				follow_path.curve.get_closest_point(
					_target_position_with_offset() - path_position
				) + path_position

		FollowMode.FRAMED:
			if not Engine.is_editor_hint():
				viewport_position = (get_follow_target().get_global_transform_with_canvas().get_origin() + follow_offset) / get_viewport_rect().size
				var framed_side_offset: Vector2 = _get_framed_side_offset()

				if framed_side_offset != Vector2.ZERO:
					var glo_pos: Vector2
					var target_position: Vector2 = _target_position_with_offset() + _follow_framed_offset

					if dead_zone_width == 0 || dead_zone_height == 0:
						if dead_zone_width == 0 && dead_zone_height != 0:
							follow_position = _target_position_with_offset()
						elif dead_zone_width != 0 && dead_zone_height == 0:
							glo_pos = _target_position_with_offset()
							glo_pos.x += target_position.x - global_position.x
							follow_position = glo_pos
						else:
							follow_position = _target_position_with_offset()

					# If a horizontal dead zone is reached
					if framed_side_offset.x != 0 and framed_side_offset.y == 0:
						follow_position.y = _transform_output.origin.y
						follow_position.x = target_position.x
						_follow_framed_offset.y = global_position.y - _target_position_with_offset().y
						dead_zone_reached.emit(Vector2(framed_side_offset.x, 0))
					# If a vertical dead zone is reached
					elif framed_side_offset.x == 0 and framed_side_offset.y != 0:
						follow_position.x = _transform_output.origin.x
						follow_position.y = target_position.y
						_follow_framed_offset.x = global_position.x - _target_position_with_offset().x
						dead_zone_reached.emit(Vector2(0, framed_side_offset.y))
					# If a deadzone corner is reached
					else:
						follow_position = target_position
						dead_zone_reached.emit(Vector2(framed_side_offset.x, framed_side_offset.y))
				else:
					_follow_framed_offset = _transform_output.origin - _target_position_with_offset()
					return
			else:
				follow_position = _target_position_with_offset()

	_interpolate_position(follow_position, delta)


func _set_follow_velocity(index: int, value: float):
	_follow_velocity_ref[index] = value


func _interpolate_position(target_position: Vector2, delta: float) -> void:
	if _limit_inactive_pcam and not _tween_skip:
		target_position = _set_limit_clamp_position(target_position)

	global_position = target_position
	if follow_damping:
		var output_position: Vector2
		for i in 2:
			output_position[i] = _smooth_damp(
				global_position[i],
				_transform_output.origin[i],
				i,
				_follow_velocity_ref[i],
				_set_follow_velocity,
				follow_damping_value[i],
				delta
			)
		_transform_output = Transform2D(global_rotation, output_position)
	else:
		_transform_output = Transform2D(global_rotation, target_position)


func _smooth_damp(target_axis: float, self_axis: float, index: int, current_velocity: float, set_velocity: Callable, damping_time: float, delta: float) -> float:
		damping_time = maxf(0.0001, damping_time)
		var omega: float = 2 / damping_time
		var x: float = omega * delta
		var exponential: float = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x)
		var diff: float = self_axis - target_axis
		var _target_axis: float = target_axis

		var max_change: float = INF * damping_time
		diff = clampf(diff, -max_change, max_change)
		target_axis = self_axis - diff

		var temp: float = (current_velocity + omega * diff) * delta
		set_velocity.call(index, (current_velocity - omega * temp) * exponential)
		var output: float = target_axis + (diff + temp) * exponential

		## To prevent overshooting
		if (_target_axis - self_axis > 0.0) == (output > _target_axis):
			output = _target_axis
			set_velocity.call(index, (output - _target_axis) / delta)

		return output


func _set_limit_clamp_position(value: Vector2) -> Vector2:
	var camera_frame_rect_size: Vector2 = _camera_frame_rect().size
	value.x = clampf(value.x, _limit_sides.x + camera_frame_rect_size.x / 2, _limit_sides.z - camera_frame_rect_size.x / 2)
	value.y = clampf(value.y, _limit_sides.y + camera_frame_rect_size.y / 2, _limit_sides.w - camera_frame_rect_size.y / 2)
	return value


func _draw() -> void:
	if not Engine.is_editor_hint(): return

	if frame_preview and not _is_active:
		var screen_size_width: int = ProjectSettings.get_setting(\"display/window/size/viewport_width\")
		var screen_size_height: int = ProjectSettings.get_setting(\"display/window/size/viewport_height\")
		var screen_size_zoom: Vector2 = Vector2(screen_size_width / get_zoom().x, screen_size_height / get_zoom().y)
		draw_rect(_camera_frame_rect(), Color(\"3ab99a\"), false, 2)


func _camera_frame_rect() -> Rect2:
	var screen_size_width: int = ProjectSettings.get_setting(\"display/window/size/viewport_width\")
	var screen_size_height: int = ProjectSettings.get_setting(\"display/window/size/viewport_height\")
	var screen_size_zoom: Vector2 = Vector2(screen_size_width / get_zoom().x, screen_size_height / get_zoom().y)

	return Rect2(-screen_size_zoom / 2, screen_size_zoom)


func _on_tile_map_changed() -> void:
	update_limit_all_sides()


func _target_position_with_offset() -> Vector2:
	return follow_target.global_position + follow_offset


func _on_dead_zone_changed() -> void:
	set_global_position( _target_position_with_offset() )


func _has_valid_pcam_owner() -> bool:
	if not is_instance_valid(get_pcam_host_owner()): return false
	if not is_instance_valid(get_pcam_host_owner().camera_2d): return false
	return true


func _get_framed_side_offset() -> Vector2:
	var frame_out_bounds: Vector2

	if viewport_position.x < 0.5 - dead_zone_width / 2:
		# Is outside left edge
		frame_out_bounds.x = -1

	if viewport_position.y < 0.5 - dead_zone_height / 2:
		# Is outside top edge
		frame_out_bounds.y = 1

	if viewport_position.x > 0.5 + dead_zone_width / 2:
		# Is outside right edge
		frame_out_bounds.x = 1

	if viewport_position.y > 0.5001 + dead_zone_height / 2: # 0.501 to resolve an issue where the bottom vertical Dead Zone never becoming 0 when the Dead Zone Vertical parameter is set to 0
		# Is outside bottom edge
		frame_out_bounds.y = -1

	return frame_out_bounds


func _draw_camera_2d_limit() -> void:
	if _has_valid_pcam_owner():
		get_pcam_host_owner().camera_2d.set_limit_drawing_enabled(draw_limits)


func _check_limit_is_not_default() -> void:
	if _limit_sides == _limit_sides_default:
		_limit_inactive_pcam = false
	else:
		_limit_inactive_pcam = true


func _set_camera_2d_limit(side: int, limit: int) -> void:
	if not _has_valid_pcam_owner(): return
	if not _is_active: return
	get_pcam_host_owner().camera_2d.set_limit(side, limit)


func _check_visibility() -> void:
	if not is_instance_valid(pcam_host_owner): return
	pcam_host_owner.refresh_pcam_list_priorty()


func _follow_target_tree_exiting(target: Node) -> void:
	if target == follow_target:
		_should_follow = false
	if _follow_targets.has(target):
		_follow_targets.erase(target)


func _should_follow_checker() -> void:
	if follow_mode == FollowMode.NONE:
		_should_follow = false
		return

	if not follow_mode == FollowMode.GROUP:
		if is_instance_valid(follow_target):
			_should_follow = true
		else:
			_should_follow = false


func _follow_targets_size_check() -> void:
	var targets_size: int = 0
	_follow_target_physics_based = false
	_follow_targets = []
	for i in follow_targets.size():
		if follow_targets[i] == null: continue
		if follow_targets[i].is_inside_tree():
			_follow_targets.append(follow_targets[i])
			targets_size += 1
			_follow_targets_single_target_index = i
			_check_physics_body(follow_targets[i])
			if not follow_targets[i].tree_exiting.is_connected(_follow_target_tree_exiting):
				follow_targets[i].tree_exiting.connect(_follow_target_tree_exiting.bind(follow_targets[i]))

	match targets_size:
		0:
			_should_follow = false
			_has_multiple_follow_targets = false
		1:
			_should_follow = true
			_has_multiple_follow_targets = false
		_:
			_should_follow = true
			_has_multiple_follow_targets = true


func _noise_emitted(emitter_noise_output: Transform2D, emitter_layer: int) -> void:
	if noise_emitter_layer & emitter_layer != 0:
		noise_emitted.emit(emitter_noise_output)

		if not pcam_host_owner.camera_2d.ignore_rotation: return
		if emitter_noise_output.get_rotation() != 0:
			push_warning(pcam_host_owner.camera_2d.name, \" has ignore_rotation enabled.\")


func _set_layer(current_layers: int, layer_number: int, value: bool) -> int:
	var mask: int = current_layers

	# From https://github.com/godotengine/godot/blob/51991e20143a39e9ef0107163eaf283ca0a761ea/scene/3d/camera_3d.cpp#L638
	if layer_number < 1 or layer_number > 20:
		printerr(\"Render layer must be between 1 and 20.\")
	else:
		if value:
			mask |= 1 << (layer_number - 1)
		else:
			mask &= ~(1 << (layer_number - 1))

	return mask


func _check_physics_body(target: Node2D) -> void:
	if target is PhysicsBody2D:
		## NOTE - Feature Toggle
		if Engine.get_version_info().major == 4 and \\
		Engine.get_version_info().minor < 3:
			if ProjectSettings.get_setting(\"phantom_camera/tips/show_jitter_tips\"):
				print_rich(\"Following a [b]PhysicsBody2D[/b] node will likely result in jitter - on lower physics ticks in particular.\")
				print_rich(\"If possible, will recommend upgrading to Godot 4.3, as it has built-in support for 2D Physics Interpolation, which will mitigate this issue.\")
				print_rich(\"Otherwise, try following the guide on the [url=https://phantom-camera.dev/support/faq#i-m-seeing-jitter-what-can-i-do]documentation site[/url] for better results.\")
				print_rich(\"This tip can be disabled from within [code]Project Settings / Phantom Camera / Tips / Show Jitter Tips[/code]\")
			return
			## NOTE - Only supported in Godot 4.3 or above
		elif not ProjectSettings.get_setting(\"physics/common/physics_interpolation\") and ProjectSettings.get_setting(\"phantom_camera/tips/show_jitter_tips\"):
			printerr(\"Physics Interpolation is disabled in the Project Settings, recommend enabling it to smooth out physics-based camera movement\")
			print_rich(\"This tip can be disabled from within [code]Project Settings / Phantom Camera / Tips / Show Jitter Tips[/code]\")
		_follow_target_physics_based = true
	else:
		_is_parents_physics(target)
	physics_target_changed.emit()


func _is_parents_physics(target: Node = self) -> void:
	var current_node: Node = target
	while current_node:
		current_node = current_node.get_parent()
		if not current_node is PhysicsBody2D: continue
		_follow_target_physics_based = true

#endregion


#region Public Functions

## Updates the limit sides based what has been set to define it
## This should be automatic, but can be called manully if need be.
func update_limit_all_sides() -> void:
	var limit_rect: Rect2

	if not is_instance_valid(_limit_node):
		_limit_sides.x = limit_left
		_limit_sides.y = limit_top
		_limit_sides.z = limit_right
		_limit_sides.w = limit_bottom
	elif _limit_node is TileMap or _limit_node.is_class(\"TileMapLayer\"):
		var tile_map := _limit_node

		if not tile_map.tile_set: return # TODO: This should be removed once https://github.com/godotengine/godot/issues/96898 is resolved

		var tile_map_size: Vector2 = Vector2(tile_map.get_used_rect().size) * Vector2(tile_map.tile_set.tile_size) * tile_map.get_scale()
		var tile_map_position: Vector2 = tile_map.global_position + Vector2(tile_map.get_used_rect().position) * Vector2(tile_map.tile_set.tile_size) * tile_map.get_scale()

		## Calculates the Rect2 based on the Tile Map position and size + margin
		limit_rect = Rect2(
			tile_map_position + Vector2(limit_margin.x, limit_margin.y),
			tile_map_size - Vector2(limit_margin.x, limit_margin.y) - Vector2(limit_margin.z, limit_margin.w)
		)

		# Left
		_limit_sides.x = roundi(limit_rect.position.x)
		# Top
		_limit_sides.y = roundi(limit_rect.position.y)
		# Right
		_limit_sides.z = roundi(limit_rect.position.x + limit_rect.size.x)
		# Bottom
		_limit_sides.w = roundi(limit_rect.position.y + limit_rect.size.y)
	elif _limit_node is CollisionShape2D:
		var collision_shape_2d: CollisionShape2D = _limit_node as CollisionShape2D

		if not collision_shape_2d.get_shape(): return

		var shape_2d: Shape2D = collision_shape_2d.get_shape()
		var shape_2d_size: Vector2 = shape_2d.get_rect().size
		var shape_2d_position: Vector2 = collision_shape_2d.global_position + Vector2(shape_2d.get_rect().position)

		## Calculates the Rect2 based on the Tile Map position and size
		limit_rect = Rect2(shape_2d_position, shape_2d_size)

		## Calculates the Rect2 based on the Tile Map position and size + margin
		limit_rect = Rect2(
			limit_rect.position + Vector2(limit_margin.x, limit_margin.y),
			limit_rect.size - Vector2(limit_margin.x, limit_margin.y) - Vector2(limit_margin.z, limit_margin.w)
		)

		# Left
		_limit_sides.x = roundi(limit_rect.position.x)
		# Top
		_limit_sides.y = roundi(limit_rect.position.y)
		# Right
		_limit_sides.z = roundi(limit_rect.position.x + limit_rect.size.x)
		# Bottom
		_limit_sides.w = roundi(limit_rect.position.y + limit_rect.size.y)

	_check_limit_is_not_default()

	if _is_active and _has_valid_pcam_owner():
		_set_camera_2d_limit(SIDE_LEFT, _limit_sides.x)
		_set_camera_2d_limit(SIDE_TOP, _limit_sides.y)
		_set_camera_2d_limit(SIDE_RIGHT, _limit_sides.z)
		_set_camera_2d_limit(SIDE_BOTTOM, _limit_sides.w)


func reset_limit() -> void:
	if not _has_valid_pcam_owner(): return
	if not _is_active: return
	get_pcam_host_owner().camera_2d.set_limit(SIDE_LEFT, _limit_sides_default.x)
	get_pcam_host_owner().camera_2d.set_limit(SIDE_TOP, _limit_sides_default.y)
	get_pcam_host_owner().camera_2d.set_limit(SIDE_RIGHT, _limit_sides_default.z)
	get_pcam_host_owner().camera_2d.set_limit(SIDE_BOTTOM, _limit_sides_default.w)


## Assigns the value of the [param has_tweened] property.
## [b][color=yellow]Important:[/color][/b] This value can only be changed
## from the [PhantomCameraHost] script.
func set_tween_skip(caller: Node, value: bool) -> void:
	if is_instance_of(caller, PhantomCameraHost):
		_tween_skip = value
	else:
		printerr(\"Can only be called PhantomCameraHost class\")
## Returns the current [param has_tweened] value.
func get_tween_skip() -> bool:
	return _tween_skip

## Returns the [Transform3D] value based on the [member follow_mode] / [member look_at_mode] target value.
func get_transform_output() -> Transform2D:
	return _transform_output


## Returns the noise [Transform3D] value.
func get_noise_transform() -> Transform2D:
	return _transform_noise


## Emits a noise based on a custom [Transform2D] value.[br]
## Use this function if you wish to make use of external noise patterns from, for example, other addons.
func emit_noise(value: Transform2D) -> void:
	noise_emitted.emit(value)

#endregion


#region Setter & Getter Functions

## Assigns the [param PhantomCamera2D] to a new [PhantomCameraHost].[br]
## [b][color=yellow]Important:[/color][/b] This is currently restricted to
## plugin internals. Proper support will be added in issue #26.
func set_pcam_host_owner(value: PhantomCameraHost) -> void:
	pcam_host_owner = value
	if is_instance_valid(pcam_host_owner):
		pcam_host_owner.pcam_added_to_scene(self)
	#if value.size() == 1:
#	else:
#		for camera_host in camera_host_group:
#			print(\"Multiple PhantomCameraBases in scene\")
#			print(pcam_host_group)
#			print(pcam.get_tree().get_nodes_in_group(PhantomCameraGroupNames.PHANTOM_CAMERA_HOST_GROUP_NAME))
#			multiple_pcam_host_group.append(camera_host)
#			return nullfunc assign_pcam_host() -> void:
## Gets the current [PhantomCameraHost] this [param PhantomCamera2D] is
## assigned to.
func get_pcam_host_owner() -> PhantomCameraHost:
	return pcam_host_owner


## Assigns new Zoom value.
func set_zoom(value: Vector2) -> void:
	zoom = value
	queue_redraw()

## Gets current Zoom value.
func get_zoom() -> Vector2:
	return zoom


## Assigns new Priority value.
func set_priority(value: int) -> void:
	priority = abs(value)
	if _has_valid_pcam_owner():
		get_pcam_host_owner().pcam_priority_updated(self)

## Gets current Priority value.
func get_priority() -> int:
	return priority


## Assigns a new PhantomCameraTween resource to the PhantomCamera2D
func set_tween_resource(value: PhantomCameraTween) -> void:
	tween_resource = value

## Gets the PhantomCameraTween resource assigned to the PhantomCamera2D
## Returns null if there's nothing assigned to it.
func get_tween_resource() -> PhantomCameraTween:
	return tween_resource


## Assigns a new [param Tween Duration] to the [member tween_resource] value.[br]
## The duration value is in seconds.
func set_tween_duration(value: float) -> void:
	tween_resource.duration = value

## Gets the current [param Tween Duration] value inside the
## [member tween_resource].[br]
## The duration value is in seconds.
func get_tween_duration() -> float:
	return tween_resource.duration


## Assigns a new [param Tween Transition] value inside the
## [member tween_resource].
func set_tween_transition(value: int) -> void:
	tween_resource.transition = value

## Gets the current [param Tween Transition] value  inside the
## [member tween_resource].
func get_tween_transition() -> int:
	return tween_resource.transition


## Assigns a new [param Tween Ease] value inside the [member tween_resource].
func set_tween_ease(value: int) -> void:
	tween_resource.ease = value

## Gets the current [param Tween Ease] value inside the [member tween_resource].
func get_tween_ease() -> int:
	return tween_resource.ease


## Sets the [param PhantomCamera2D] active state.[br]
## [b][color=yellow]Important:[/color][/b] This value can only be changed
## from the [PhantomCameraHost] script.
func set_is_active(node, value) -> void:
	if node is PhantomCameraHost:
		_is_active = value
		if value:
			_should_follow_checker()
	else:
		printerr(\"PCams can only be set from the PhantomCameraHost\")

## Gets current active state of the [param PhantomCamera2D].
## If it returns true, it means the [param PhantomCamera2D] is what the
## [param Camera2D] is currently following.
func is_active() -> bool:
	return _is_active


## Enables or disables the [member tween_on_load].
func set_tween_on_load(value: bool) -> void:
	tween_on_load = value

## Gets the current [member tween_on_load] value.
func get_tween_on_load() -> bool:
	return tween_on_load


## Gets the current follow mode as an enum int based on [enum FollowMode].[br]
## [b]Note:[/b] Setting [enum FollowMode] purposely not added.
## A separate PCam should be used instead.
func get_follow_mode() -> int:
	return follow_mode


## Assigns a new [Node2D] as the [member follow_target].
func set_follow_target(value: Node2D) -> void:
	if follow_mode == FollowMode.NONE or follow_mode == FollowMode.GROUP: return
	if follow_target == value: return
	follow_target = value
	_follow_target_physics_based = false
	if is_instance_valid(value):
		if follow_mode == FollowMode.PATH:
			if is_instance_valid(follow_path):
				_should_follow = true
			else:
				_should_follow = false
		else:
			_should_follow = true
		_check_physics_body(value)
		if not follow_target.tree_exiting.is_connected(_follow_target_tree_exiting):
			follow_target.tree_exiting.connect(_follow_target_tree_exiting.bind(follow_target))
	else:
		_should_follow = false
	follow_target_changed.emit()
	notify_property_list_changed()

## Erases the current [member follow_target].
func erase_follow_target() -> void:
	if follow_target == null: return
	_should_follow = false
	follow_target = null
	_follow_target_physics_based = false
	follow_target_changed.emit()

## Gets the current [member follow_target].
func get_follow_target() -> Node2D:
	return follow_target


## Assigns a new [Path2D] to the [member follow_path].
func set_follow_path(value: Path2D) -> void:
	follow_path = value
	if is_instance_valid(follow_path):
		_should_follow_checker()
	else:
		_should_follow = false

## Erases the current [Path2D] from the [member follow_path] property.
func erase_follow_path() -> void:
	follow_path = null

## Gets the current [Path2D] from the [member follow_path].
func get_follow_path() -> Path2D:
	return follow_path


## Assigns a new [param follow_targets] array value.
func set_follow_targets(value: Array[Node2D]) -> void:
	if follow_mode != FollowMode.GROUP: return
	if follow_targets == value: return
	follow_targets = value
	_follow_targets_size_check()

## Appends a single [Node2D] to [member follow_targets].
func append_follow_targets(value: Node2D) -> void:
	if not is_instance_valid(value):
		printerr(value, \" is not a valid Node2D instance\")
		return

	if not follow_targets.has(value):
		follow_targets.append(value)
		_follow_targets_size_check()
	else:
		printerr(value, \" is already part of Follow Group\")

## Adds an Array of type [Node2D] to [member follow_targets].
func append_follow_targets_array(value: Array[Node2D]) -> void:
	for target in value:
		if not is_instance_valid(target): continue
		if not follow_targets.has(target):
			follow_targets.append(target)
			_follow_targets_size_check()
		else:
			printerr(value, \" is already part of Follow Group\")

## Removes a [Node2D] from [member follow_targets] array.
func erase_follow_targets(value: Node2D) -> void:
	follow_targets.erase(value)
	_follow_targets_size_check()

## Gets all [Node2D] from [member follow_targets] array.
func get_follow_targets() -> Array[Node2D]:
	return follow_targets


## Assigns a new Vector2 for the Follow Target Offset property.
func set_follow_offset(value: Vector2) -> void:
	follow_offset = value

## Gets the current Vector2 for the Follow Target Offset property.
func get_follow_offset() -> Vector2:
	return follow_offset


## Enables or disables Follow Damping.
func set_follow_damping(value: bool) -> void:
	follow_damping = value
	notify_property_list_changed()

## Gets the current Follow Damping property.
func get_follow_damping() -> bool:
	return follow_damping


## Assigns new Damping value.
func set_follow_damping_value(value: Vector2) -> void:
	## TODO - Should be using @export_range once minimum version support is Godot 4.3
	if value.x < 0: value.x = 0
	elif value.y < 0: value.y = 0
	follow_damping_value = value

## Gets the current Follow Damping value.
func get_follow_damping_value() -> Vector2:
	return follow_damping_value


func set_lock_axis(value: FollowLockAxis) -> void:
	follow_axis_lock = value

	# Wait for the node to be ready before setting lock
	if not is_node_ready(): await ready

	# Prevent axis lock from working in the editor
	if value != FollowLockAxis.NONE and not Engine.is_editor_hint():
		_follow_axis_is_locked = true
		match value:
			FollowLockAxis.X:
				_follow_axis_lock_value.x = _transform_output.origin.x
			FollowLockAxis.Y:
				_follow_axis_lock_value.y = _transform_output.origin.y
			FollowLockAxis.XY:
				_follow_axis_lock_value.x = _transform_output.origin.x
				_follow_axis_lock_value.y = _transform_output.origin.y
	else:
		_follow_axis_is_locked = false

func get_lock_axis() -> FollowLockAxis:
	return follow_axis_lock


## Enables or disables [member snap_to_pixel].
func set_snap_to_pixel(value: bool) -> void:
	snap_to_pixel = value

## Gets the current [member snap_to_pixel] value.
func get_snap_to_pixel() -> bool:
	return snap_to_pixel


## Enables or disables Auto zoom when using Group Follow.
func set_auto_zoom(value: bool) -> void:
	auto_zoom = value
	notify_property_list_changed()

## Gets Auto Zoom state.
func get_auto_zoom() -> bool:
	return auto_zoom


## Assigns new Min Auto Zoom value.
func set_auto_zoom_min(value: float) -> void:
	auto_zoom_min = value

## Gets Min Auto Zoom value.
func get_auto_zoom_min() -> float:
	return auto_zoom_min


## Assigns new Max Auto Zoom value.
func set_auto_zoom_max(value: float) -> void:
	auto_zoom_max = value

## Gets Max Auto Zoom value.
func get_auto_zoom_max() -> float:
	return auto_zoom_max


## Assigns new Zoom Auto Margin value.
func set_auto_zoom_margin(value: Vector4) -> void:
	auto_zoom_margin = value

## Gets Zoom Auto Margin value.
func get_auto_zoom_margin() -> Vector4:
	return auto_zoom_margin


## Sets a limit side based on the side parameter.[br]
## It's recommended to pass the [enum Side] enum as the sid parameter.
func set_limit(side: int, value: int) -> void:
	match side:
		SIDE_LEFT: 		limit_left = value
		SIDE_TOP: 		limit_top = value
		SIDE_RIGHT: 	limit_right = value
		SIDE_BOTTOM: 	limit_bottom = value
		_:				printerr(\"Not a valid Side.\")

## Gets the limit side
func get_limit(value: int) -> int:
	match value:
		SIDE_LEFT: 		return limit_left
		SIDE_TOP: 		return limit_top
		SIDE_RIGHT: 	return limit_right
		SIDE_BOTTOM: 	return limit_bottom
		_:
						printerr(\"Not a valid Side.\")
						return -1


## Assign a the Camera2D Left Limit Side value.
func set_limit_left(value: int) -> void:
	_limit_target_exist_error()
	limit_left = value
	update_limit_all_sides()

## Gets the Camera2D Left Limit value.
func get_limit_left() -> int:
	return limit_left


## Assign a the Camera2D Top Limit Side value.
func set_limit_top(value: int) -> void:
	_limit_target_exist_error()
	limit_top = value
	update_limit_all_sides()

## Gets the Camera2D Top Limit value.
func get_limit_top() -> int:
	return limit_top


## Assign a the Camera2D Right Limit Side value.
func set_limit_right(value: int) -> void:
	_limit_target_exist_error()
	limit_right = value
	update_limit_all_sides()

## Gets the Camera2D Right Limit value.
func get_limit_right() -> int:
	return limit_right


## Assign a the Camera2D Bottom Limit Side value.
func set_limit_bottom(value: int) -> void:
	_limit_target_exist_error()
	limit_bottom = value
	update_limit_all_sides()

## Gets the Camera2D Bottom Limit value.
func get_limit_bottom() -> int:
	return limit_bottom


func _limit_target_exist_error() -> void:
	if not limit_target.is_empty():
		printerr(\"Unable to set Limit Side due to Limit Target \", _limit_node.name,  \" being assigned\")


# Sets a [memeber limit_target] node.
func set_limit_target(value: NodePath) -> void:
	limit_target = value

	# Waits for PCam2d's _ready() before trying to validate limit_node_path
	if not is_node_ready(): await ready

	# Removes signal from existing TileMap node
	if is_instance_valid(get_node_or_null(value)):
		var prev_limit_node: Node2D = _limit_node
		var new_limit_node: Node2D = get_node(value)

		if prev_limit_node:
			if prev_limit_node is TileMap or prev_limit_node.is_class(\"TileMapLayer\"):
				if prev_limit_node.changed.is_connected(_on_tile_map_changed):
					prev_limit_node.changed.disconnect(_on_tile_map_changed)

		if new_limit_node is TileMap or new_limit_node.is_class(\"TileMapLayer\"):
			if not new_limit_node.changed.is_connected(_on_tile_map_changed):
				new_limit_node.changed.connect(_on_tile_map_changed)
		elif new_limit_node is CollisionShape2D:
			var col_shape: CollisionShape2D = get_node(value)

			if col_shape.shape == null:
				printerr(\"No Shape2D in: \", col_shape.name)
				reset_limit()
				limit_target = \"\"
				return
		else:
			printerr(\"Limit Target is not a TileMap, TileMapLayer or CollisionShape2D node\")
			return

	elif value == NodePath(\"\"):
		reset_limit()
		limit_target = \"\"
	else:
		printerr(\"Limit Target cannot be found\")
		return

	_limit_node = get_node_or_null(value)

	notify_property_list_changed()
	update_limit_all_sides()

## Get [member limit_target] node.
func get_limit_target() -> NodePath:
	if not limit_target: # TODO - Fixes an spam error if if limit_taret is empty
		return NodePath(\"\")
	else:
		return limit_target


## Set Tile Map Limit Margin.
func set_limit_margin(value: Vector4i) -> void:
	limit_margin = value
	update_limit_all_sides()
## Get Tile Map Limit Margin.
func get_limit_margin() -> Vector4i:
	return limit_margin


### Enables or disables the Limit Smoothing beaviour.
#func set_limit_smoothing(value: bool) -> void:
	#limit_smoothed = value
	#if is_active() and _has_valid_pcam_owner():
		#get_pcam_host_owner().camera_2d.reset_smoothing()
### Returns the Limit Smoothing beaviour.
#func get_limit_smoothing() -> bool:
	#return limit_smoothed


## Sets a [PhantomCameraNoise2D] resource.
func set_noise(value: PhantomCameraNoise2D) -> void:
	noise = value
	if value != null:
		_has_noise_resource = true
		noise.set_trauma(1)
	else:
		_has_noise_resource = false
		_transform_noise = Transform2D()

## Returns the [PhantomCameraNoise2D] resource.
func get_noise() -> PhantomCameraNoise2D:
	return noise


## Sets the [member noise_emitter_layer] value.
func set_noise_emitter_layer(value: int) -> void:
	noise_emitter_layer = value

## Enables or disables a given layer of the [member noise_emitter_layer] value.
func set_noise_emitter_layer_value(value: int, enabled: bool) -> void:
	noise_emitter_layer = _set_layer(noise_emitter_layer, value, enabled)

## Returns the [member noise_emitter_layer]
func get_noise_emitter_layer() -> int:
	return noise_emitter_layer


## Sets [member inactive_update_mode] property.
func set_inactive_update_mode(value: int) -> void:
	inactive_update_mode = value

## Gets [enum InactiveUpdateMode] value.
func get_inactive_update_mode() -> int:
	return inactive_update_mode


func get_follow_target_physics_based() -> bool:
	return _follow_target_physics_based


func get_class() -> String:
	return \"PhantomCamera2D\"


func is_class(value) -> bool:
	return value == \"PhantomCamera2D\"

#endregion
"

[sub_resource type="GDScript" id="GDScript_ls8k5"]
script/source = "@icon(\"res://addons/phantom_camera/icons/phantom_camera_tween.svg\")
class_name PhantomCameraTween
extends Resource

## Tweening resource for [PhantomCamera2D] and [PhantomCamera3D].
##
## Defines how [param PhantomCameras] transition between one another.
## Changing the tween values for a given [param PhantomCamera] determines how
## transitioning to that instance will look like.

enum TransitionType {
	LINEAR 	= 0, ## The animation is interpolated linearly.
	SINE 	= 1, ## The animation is interpolated using a sine function.
	QUINT 	= 2, ## The animation is interpolated with a quintic (to the power of 5) function.
	QUART 	= 3, ## The animation is interpolated with a quartic (to the power of 4) function.
	QUAD 	= 4, ## The animation is interpolated with a quadratic (to the power of 2) function.
	EXPO 	= 5, ## The animation is interpolated with an exponential (to the power of x) function.
	ELASTIC = 6, ## The animation is interpolated with elasticity, wiggling around the edges.
	CUBIC 	= 7, ## The animation is interpolated with a cubic (to the power of 3) function.
	CIRC 	= 8, ## The animation is interpolated with a function using square roots.
	BOUNCE 	= 9, ## The animation is interpolated by bouncing at the end.
	BACK 	= 10, ## The animation is interpolated backing out at ends.
#	CUSTOM 	= 11,
#	NONE 	= 12,
}

enum EaseType {
	EASE_IN 	= 0, ## The interpolation starts slowly and speeds up towards the end.
	EASE_OUT 	= 1, ## The interpolation starts quickly and slows down towards the end.
	EASE_IN_OUT = 2, ## A combination of EASE_IN and EASE_OUT. The interpolation is slowest at both ends.
	EASE_OUT_IN = 3, ## A combination of EASE_IN and EASE_OUT. The interpolation is fastest at both ends.
}

## The time it takes to tween to this PhantomCamera in [param seconds].
@export var duration: float = 1

## The transition bezier type for the tween. The options are defined in the [enum TransitionType].
@export var transition: TransitionType = TransitionType.LINEAR

## The ease type for the tween. The options are defined in the [enum EaseType].
@export var ease: EaseType = EaseType.EASE_IN_OUT
"

[sub_resource type="Resource" id="Resource_rthbw"]
script = SubResource("GDScript_ls8k5")
duration = 1.0
transition = 0
ease = 2

[sub_resource type="TileSetAtlasSource" id="TileSetAtlasSource_33esx"]
texture = ExtResource("4_5728d")
texture_region_size = Vector2i(48, 48)
0:0/0 = 0
0:0/0/custom_data_0 = true
1:0/0 = 0
1:0/0/custom_data_0 = true
2:0/0 = 0
2:0/0/custom_data_0 = true
3:0/0 = 0
3:0/0/custom_data_0 = true
4:0/0 = 0
4:0/0/custom_data_0 = true
5:0/0 = 0
5:0/0/custom_data_0 = true
0:1/0 = 0
0:1/0/custom_data_0 = true
1:1/0 = 0
1:1/0/custom_data_0 = true
2:1/0 = 0
2:1/0/custom_data_0 = true
3:1/0 = 0
3:1/0/custom_data_0 = true
4:1/0 = 0
4:1/0/custom_data_0 = true
5:1/0 = 0
5:1/0/custom_data_0 = true
0:2/0 = 0
0:2/0/custom_data_0 = true
1:2/0 = 0
1:2/0/custom_data_0 = true
2:2/0 = 0
2:2/0/custom_data_0 = true
3:2/0 = 0
3:2/0/custom_data_0 = true
4:2/0 = 0
4:2/0/custom_data_0 = true
5:2/0 = 0
5:2/0/custom_data_0 = true
0:3/0 = 0
0:3/0/custom_data_0 = true
1:3/0 = 0
1:3/0/custom_data_0 = true
2:3/0 = 0
2:3/0/custom_data_0 = true
3:3/0 = 0
3:3/0/custom_data_0 = true
0:4/0 = 0
0:4/0/physics_layer_0/polygon_0/points = PackedVector2Array(-24, -24, 24, -24, 24, 24, -24, 24)
1:4/0 = 0
1:4/0/physics_layer_0/polygon_0/points = PackedVector2Array(24, -6, 6, -6, 0, 0, -6, 18, -6, 24, -24, 24, -24, -24, 24, -24)
1:4/0/custom_data_0 = true
2:4/0 = 0
2:4/0/physics_layer_0/polygon_0/points = PackedVector2Array(-24, -24, 24, -24, 24, -6, -24, -6)
2:4/0/custom_data_0 = true
3:4/0 = 0
3:4/0/physics_layer_0/polygon_0/points = PackedVector2Array(-24, -24, 24, -24, 24, 24, 12, 24, 12, 18, 6, 6, -6, -6, -24, -6)
3:4/0/custom_data_0 = true
4:4/0 = 0
4:4/0/physics_layer_0/polygon_0/points = PackedVector2Array(12, 0, 24, -12, 24, 24, 12, 24)
4:4/0/custom_data_0 = true
5:4/0 = 0
5:4/0/physics_layer_0/polygon_0/points = PackedVector2Array(-24, 24, -24, -12, -18, -12, -12, -6, -12, 6, -12, 12, -12, 24)
5:4/0/custom_data_0 = true
0:5/0 = 0
0:5/0/physics_layer_0/polygon_0/points = PackedVector2Array(-24, -24, 24, -24, 24, 24, -24, 24)
1:5/0 = 0
1:5/0/physics_layer_0/polygon_0/points = PackedVector2Array(-24, -24, -6, -24, -6, 24, -24, 24)
1:5/0/custom_data_0 = true
2:5/0 = 0
2:5/0/custom_data_0 = true
3:5/0 = 0
3:5/0/physics_layer_0/polygon_0/points = PackedVector2Array(12, -24, 24, -24, 24, 24, 12, 24)
3:5/0/custom_data_0 = true
4:5/0 = 0
4:5/0/physics_layer_0/polygon_0/points = PackedVector2Array(24, -24, 12, -24, 15.5625, -15, 24, -12)
4:5/0/custom_data_0 = true
5:5/0 = 0
5:5/0/physics_layer_0/polygon_0/points = PackedVector2Array(-24, -24, -24, -11.625, -12, -12, -12, -24)
5:5/0/custom_data_0 = true
0:6/0 = 0
0:6/0/physics_layer_0/polygon_0/points = PackedVector2Array(-24, -24, 24, -24, 24, 24, -24, 24)
1:6/0 = 0
1:6/0/physics_layer_0/polygon_0/points = PackedVector2Array(-24, -24, -6, -24, -6, -18, 6, -12, 24, -12, 24, 24, -24, 24)
2:6/0 = 0
2:6/0/physics_layer_0/polygon_0/points = PackedVector2Array(-24, -12, 24, -12, 24, 24, -24, 24)
3:6/0 = 0
3:6/0/physics_layer_0/polygon_0/points = PackedVector2Array(-24, -12, -6, -12, 6, -18, 12, -24, 24, -24, 24, 24, -24, 24)
4:6/0 = 0
4:6/0/physics_layer_0/polygon_0/points = PackedVector2Array(24, 24, 24, -12, 12, 0, 12, 24)
4:6/0/physics_layer_0/polygon_1/points = PackedVector2Array(-12, -12, -12, -24, -24, -24, -24, -12)
4:6/0/custom_data_0 = true
5:6/0 = 0
5:6/0/physics_layer_0/polygon_0/points = PackedVector2Array(-24, 24, -24, -12, -18, -12, -12, -6, -12, 12, -12, 24)
5:6/0/physics_layer_0/polygon_1/points = PackedVector2Array(18, -18, 24, -12, 24, -24, 12, -24)
5:6/0/custom_data_0 = true
0:7/0 = 0
0:7/0/physics_layer_0/polygon_0/points = PackedVector2Array(-24, -24, 24, -24, 24, 24, -24, 24)
1:7/0 = 0
1:7/0/physics_layer_0/polygon_0/points = PackedVector2Array(-24, -24, 24, -24, 24, 24, -24, 24)
2:7/0 = 0
2:7/0/physics_layer_0/polygon_0/points = PackedVector2Array(-24, -24, 24, -24, 24, 24, -24, 24)
3:7/0 = 0
3:7/0/physics_layer_0/polygon_0/points = PackedVector2Array(-24, -24, 24, -24, 24, 24, -24, 24)
0:8/0 = 0
1:8/0 = 0
2:8/0 = 0
3:8/0 = 0
4:8/0 = 0
5:8/0 = 0
0:9/0 = 0
1:9/0 = 0
2:9/0 = 0
3:9/0 = 0
4:9/0 = 0
5:9/0 = 0
0:10/0 = 0
1:10/0 = 0
2:10/0 = 0
3:10/0 = 0
4:10/0 = 0
5:10/0 = 0
0:11/0 = 0
1:11/0 = 0
2:11/0 = 0
3:11/0 = 0
4:11/0 = 0
5:11/0 = 0
4:3/0 = 0
4:3/0/physics_layer_0/polygon_0/points = PackedVector2Array(-24, -24, 24, -24, 24, 24, -24, 24)
5:3/0 = 0
5:3/0/physics_layer_0/polygon_0/points = PackedVector2Array(-24, -24, 24, -24, 24, 24, -24, 24)

[sub_resource type="TileSetAtlasSource" id="TileSetAtlasSource_sps5y"]
texture = ExtResource("5_4trq1")
0:0/0 = 0
1:1/0 = 0
2:2/0 = 0
3:2/0 = 0
3:3/0 = 0
2:3/0 = 0
1:3/0 = 0
0:3/0 = 0
0:2/0 = 0
0:1/0 = 0
2:1/0 = 0
1:2/0 = 0
1:0/0 = 0
2:0/0 = 0
3:0/0 = 0
3:1/0 = 0

[sub_resource type="TileSet" id="TileSet_3qvaf"]
tile_size = Vector2i(48, 48)
physics_layer_0/collision_layer = 1
custom_data_layer_0/name = "Walkable"
custom_data_layer_0/type = 1
sources/0 = SubResource("TileSetAtlasSource_33esx")
sources/1 = SubResource("TileSetAtlasSource_sps5y")

[sub_resource type="TileSetAtlasSource" id="TileSetAtlasSource_l6w6c"]
texture = ExtResource("6_kwc70")
texture_region_size = Vector2i(48, 48)
0:0/0 = 0

[sub_resource type="TileSet" id="TileSet_ol3dr"]
tile_size = Vector2i(48, 48)
sources/0 = SubResource("TileSetAtlasSource_l6w6c")

[sub_resource type="NavigationPolygon" id="NavigationPolygon_aqjx3"]
vertices = PackedVector2Array(362, -758, 374, -758, 374, -740, 310, -74.2969, 310, -86, 316, -86, 454, -122.297, 454, -134, 460, -134, 698, -28.1406, 698, -4.14063, 696.07, -2.21094, 687.648, 2, 667.859, 2, 502, -170.297, 502, -182, 508, -182, 550, -218.297, 550, -230, 556, -230, 715.859, -46, 598, -314.297, 598, -326, 604, -326, 646, -458.297, 646, -470, 652, -470, 844, 38, 838, 38, 838, 13.8594, 796, -10, 790, -10, 790, -34.1406, -212, 134, -218, 134, -218, 109.859, -218, -26.2969, -218, -38, -212, -38, 207.648, 146, 230, -68, 235.859, 50, 218, 67.8594, -26, -218.297, -26, -230, -20, -230, 223.93, -79.1016, 74, -364.141, -20, -346, -26, -346, -26, -370.141, 91.8594, -382, -164, -490, -170, -490, -170, -514.141, 264.07, -386.211, 255.648, -382, -170, -698.297, -170, -710, -164, -710, 266, -460.141, 266, -388.141, -122, -746.297, -122, -758, -116, -758, 118, -794.297, 118, -806, 124, -806, 319.93, -799.102, 326, -796.938, 326, -788, 314, -556.141, 298, -68, 298, -73.9219, 650, 19.8594, 442, -116, 442, -121.922, 490, -164, 490, -169.922, 538, -212, 538, -217.922, 586, -308, 586, -313.922, 778.141, -46, 634, -452, 634, -457.922, -229.859, 98, -230, -20, -230, -25.9219, 218, 139.859, 216.07, 141.789, -38, -212, -38, -217.922, -181.859, -526, -182, -692, -182, -697.922, -134, -740, -134, -745.922, 312.07, -482.211, 303.648, -478, 283.859, -478, 106, -788, 106, -793.922, 314, -484.141, 79.9297, -223.102, 86, -220.938, 86, -212, 230, -76.9375, 895.93, -463.102, 902, -460.938, 902, -452, 991.93, -415.102, 998, -412.938, 998, -404, 1039.93, -367.102, 1046, -364.938, 1046, -356, 1087.93, -319.102, 1094, -316.938, 1094, -308, 800.352, 2, 796, -0.171875, 826.141, 2, -159.648, -382, -164, -384.172, -37.8594, -382, -255.648, -526, -260, -528.172, -260, -676.367, -255.25, -690.602, -253.859, -692, 848.352, 98, 844, 95.8203, 975.648, 98, -207.648, 146, -212, 143.82, -495.648, 98, -500, 95.8203, -500, -4.36719, -495.25, -18.6016, -493.859, -20, 986, 91.8594, 984.07, 93.7891, 986, 67.8594, 1003.86, 50, -212, -196.367, -207.25, -210.602, -205.859, -212, -164, -724.367, -159.25, -738.602, -157.859, -740, -116, -772.367, -111.25, -786.602, -109.859, -788, 349.859, -788, 357.789, -780.07, 362, -771.648, 397.859, -740, 405.789, -732.07, 410, -723.648, 410, -628.141, 408.07, -626.211, 399.648, -622, 379.859, -622, 362, -604.141, 362, -580.141, 360.07, -578.211, 351.648, -574, 331.859, -574, 205.859, -212, 213.789, -204.07, 218, -195.648, 218, -94.0938, 316, -100.367, 320.742, -114.602, 322.141, -116, 460, -148.367, 464.742, -162.602, 466.141, -164, 508, -196.367, 512.742, -210.602, 514.141, -212, 556, -292.367, 560.742, -306.602, 562.141, -308, 604, -436.367, 608.742, -450.602, 610.141, -452, 877.859, -500, 885.789, -492.07, 890, -483.648, 890, -478.094, 652, -484.367, 656.742, -498.602, 658.141, -500, 973.859, -452, 981.789, -444.07, 986, -435.648, 986, -430.094, 1021.86, -404, 1029.79, -396.07, 1034, -387.648, 1034, -382.094, 1069.86, -356, 1077.79, -348.07, 1082, -339.648, 1082, -334.094, 1117.86, -308, 1125.79, -300.07, 1130, -291.648, 1130, -4.14063, 1128.07, -2.21094, 1119.65, 2, 1099.86, 2, 1082, 19.8594, 1082, 43.8594, 1080.07, 45.7891, 1071.65, 50, 650, 43.8594, 648.07, 45.7891, 639.648, 50, 74, -238.094, 124, -820.367, 128.742, -834.602, 130.141, -836, 301.859, -836, 309.789, -828.07, 314, -819.648, 314, -814.094)
polygons = Array[PackedInt32Array]([PackedInt32Array(0, 1, 2), PackedInt32Array(3, 4, 5), PackedInt32Array(6, 7, 8, 9, 10, 11, 12, 13), PackedInt32Array(14, 15, 16, 9), PackedInt32Array(17, 18, 19, 20, 9), PackedInt32Array(21, 22, 23), PackedInt32Array(24, 25, 26), PackedInt32Array(27, 28, 29), PackedInt32Array(30, 31, 32), PackedInt32Array(33, 34, 35), PackedInt32Array(36, 37, 38, 39), PackedInt32Array(40, 41, 42, 43, 44, 45, 46), PackedInt32Array(47, 48, 49, 50, 51), PackedInt32Array(52, 53, 54), PackedInt32Array(55, 56, 51, 57, 58, 59, 60, 61), PackedInt32Array(62, 63, 64), PackedInt32Array(65, 66, 67, 68, 69, 70, 71), PackedInt32Array(72, 73, 3), PackedInt32Array(74, 75, 76, 6, 13), PackedInt32Array(77, 78, 14, 9), PackedInt32Array(79, 80, 17, 9), PackedInt32Array(20, 81, 82, 21, 83), PackedInt32Array(84, 85, 24), PackedInt32Array(35, 86, 87, 88, 36, 39), PackedInt32Array(89, 90, 39, 91, 92, 43, 42), PackedInt32Array(54, 93, 94, 95, 57, 51), PackedInt32Array(96, 97, 62, 60), PackedInt32Array(98, 99, 100, 101, 102, 65, 71, 103), PackedInt32Array(104, 105, 106, 45), PackedInt32Array(46, 107, 40), PackedInt32Array(108, 109, 110, 23), PackedInt32Array(21, 23, 111, 112, 113, 83), PackedInt32Array(114, 115, 116, 83), PackedInt32Array(83, 117, 118, 119, 32), PackedInt32Array(120, 121, 30, 122), PackedInt32Array(123, 124, 52, 125), PackedInt32Array(93, 126, 127, 128, 129, 130, 94), PackedInt32Array(131, 132, 27, 133), PackedInt32Array(134, 135, 33, 39), PackedInt32Array(39, 33, 35), PackedInt32Array(86, 136, 137, 138, 139, 140, 87), PackedInt32Array(122, 30, 32, 119), PackedInt32Array(141, 142, 133, 27, 29, 143), PackedInt32Array(119, 144, 143, 29, 122), PackedInt32Array(39, 38, 145, 146, 147, 91), PackedInt32Array(59, 148, 149, 150, 96, 60), PackedInt32Array(151, 152, 153, 101, 64), PackedInt32Array(60, 62, 64, 101, 100), PackedInt32Array(70, 154, 155, 156, 0), PackedInt32Array(2, 157, 158, 159, 160, 161, 162, 163), PackedInt32Array(2, 163, 164, 70, 0), PackedInt32Array(164, 165, 166, 167, 168, 70), PackedInt32Array(106, 169, 170, 171, 172), PackedInt32Array(173, 174, 175, 75, 5), PackedInt32Array(3, 5, 75), PackedInt32Array(8, 176, 177, 178, 77, 9), PackedInt32Array(16, 179, 180, 181, 79, 9), PackedInt32Array(19, 182, 183, 184, 81, 20), PackedInt32Array(185, 186, 187, 84, 23), PackedInt32Array(23, 84, 24, 188, 189, 190, 191), PackedInt32Array(192, 193, 194, 188, 26), PackedInt32Array(24, 26, 188), PackedInt32Array(23, 191, 108), PackedInt32Array(110, 195, 196, 197, 198), PackedInt32Array(110, 198, 111, 23), PackedInt32Array(113, 199, 200, 201, 202, 83), PackedInt32Array(116, 203, 204, 205, 206, 83), PackedInt32Array(119, 207, 208, 209, 210, 211, 212, 213), PackedInt32Array(119, 213, 214, 144), PackedInt32Array(214, 215, 216, 217, 144), PackedInt32Array(206, 117, 83), PackedInt32Array(202, 114, 83), PackedInt32Array(3, 75, 74, 218, 219, 220, 41, 72), PackedInt32Array(40, 72, 41), PackedInt32Array(172, 46, 45, 106), PackedInt32Array(221, 104, 45, 48), PackedInt32Array(47, 221, 48), PackedInt32Array(51, 50, 125), PackedInt32Array(67, 222, 223, 224, 225, 226, 227, 228), PackedInt32Array(67, 228, 68), PackedInt32Array(51, 125, 52, 54), PackedInt32Array(168, 71, 70)])
outlines = Array[PackedVector2Array]([PackedVector2Array(-516, 201, 1154, 199, 1158, -852, -524, -855)])

[sub_resource type="AtlasTexture" id="AtlasTexture_4d2lx"]
atlas = ExtResource("5_4trq1")
region = Rect2(0, 48, 16, 16)

[sub_resource type="GDScript" id="GDScript_8kgpg"]
script/source = "@tool
@icon(\"res://addons/phantom_camera/icons/phantom_camera_host.svg\")
class_name PhantomCameraHost
extends Node

## Controls a scene's [Camera2D] (2D scenes) and [Camera3D] (3D scenes).
##
## All instantiated [param PhantomCameras] in a scene are assign to and managed by a
## PhantomCameraHost. It is what determines which [param PhantomCamera] should
## be active.

#region Constants

const _constants := preload(\"res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_constants.gd\")

#endregion

#region

## TBD - For when Godot 4.3 becomes the minimum version
#@export var interpolation_mode: InterpolationMode = InterpolationMode.AUTO:
	#set = set_interpolation_mode,
	#get = get_interpolation_mode

#endregion

#region Signals

## Updates the viewfinder [param dead zones] sizes.[br]
## [b]Note:[/b] This is only being used in the editor viewfinder UI.
signal update_editor_viewfinder

#endregion

#region Variables

enum InterpolationMode {
	AUTO    = 0,
	IDLE    = 1,
	PHYSICS = 2,
}

#endregion

#region Private Variables

var _pcam_list: Array[Node] = []

var _active_pcam_2d: PhantomCamera2D = null
var _active_pcam_3d: Node = null ## Note: To support disable_3d export templates for 2D projects, this is purposely not strongly typed.
var _active_pcam_priority: int = -1
var _active_pcam_missing: bool = true
var _active_pcam_has_damping: bool = false
var _follow_target_physics_based: bool = false

var _prev_active_pcam_2d_transform: Transform2D = Transform2D()
var _prev_active_pcam_3d_transform: Transform3D = Transform3D()

var _trigger_pcam_tween: bool = false
var _tween_elapsed_time: float = 0
var _tween_duration: float = 0
var _tween_is_instant: bool = false

var _multiple_pcam_hosts: bool = false

var _is_child_of_camera: bool = false
var _is_2D: bool = false

var _viewfinder_node: Control = null
var _viewfinder_needed_check: bool = true

var _camera_zoom: Vector2 = Vector2.ONE

#region Camera3DResource

var _prev_cam_attributes: CameraAttributes = null
var _cam_attribute_type: int = 0 # 0 = CameraAttributesPractical, 1 = CameraAttributesPhysical
var _cam_attribute_changed: bool = false
var _cam_attribute_assigned: bool = false

#region CameraAttributes
var _prev_cam_auto_exposure_scale: float = 0.4
var _cam_auto_exposure_scale_changed: bool = false

var _prev_cam_auto_exposure_speed: float = 0.5
var _cam_auto_exposure_speed_changed: bool = false

var _prev_cam_exposure_multiplier: float = 1.0
var _cam_exposure_multiplier_changed: bool = false

var _prev_cam_exposure_sensitivity: float = 100.0
var _cam_exposure_sensitivity_changed: bool = false

#region CameraAttributesPractical
var _prev_cam_exposure_min_sensitivity: float = 0.0
var _cam_exposure_min_sensitivity_changed: bool = false

var _prev_cam_exposure_max_sensitivity: float = 800.0
var _cam_exposure_max_sensitivity_changed: bool = false

var _prev_cam_dof_blur_amount: float = 0.1
var _cam_dof_blur_amount_changed: bool = false

var _cam_dof_blur_far_distance_default: float = 10
var _prev_cam_dof_blur_far_distance: float = _cam_dof_blur_far_distance_default
var _cam_dof_blur_far_distance_changed: bool = false

var _cam_dof_blur_far_transition_default: float = 5
var _prev_cam_dof_blur_far_transition: float = _cam_dof_blur_far_transition_default
var _cam_dof_blur_far_transition_changed: bool = false

var _cam_dof_blur_near_distance_default: float = 2
var _prev_cam_dof_blur_near_distance: float = _cam_dof_blur_near_distance_default
var _cam_dof_blur_near_distance_changed: bool = false

var _cam_dof_blur_near_transition_default: float = 1
var _prev_cam_dof_blur_near_transition: float = _cam_dof_blur_near_transition_default
var _cam_dof_blur_near_transition_changed: bool = false
#endregion

#region CameraAttributesPhysical
var _prev_cam_exposure_min_exposure_value: float = 10.0
var _cam_exposure_min_exposure_value_changed: bool = false

var _prev_cam_exposure_max_exposure_value: float = -8.0
var _cam_exposure_max_exposure_value_changed: bool = false

var _prev_cam_exposure_aperture: float = 16.0
var _cam_exposure_aperture_changed: bool = false

var _prev_cam_exposure_shutter_speed: float = 100.0
var _cam_exposure_shutter_speed_changed: bool = false

var _prev_cam_frustum_far: float = 4000.0
var _cam_frustum_far_changed: bool = false

var _prev_cam_frustum_focal_length: float = 35.0
var _cam_frustum_focal_length_changed: bool = false

var _prev_cam_frustum_near: float = 0.05
var _cam_frustum_near_changed: bool = false

var _prev_cam_frustum_focus_distance: float = 10.0
var _cam_frustum_focus_distance_changed: bool = false

#endregion

var _prev_cam_h_offset: float = 0
var _cam_h_offset_changed: bool = false

var _prev_cam_v_offset: float = 0
var _cam_v_offset_changed: bool = false

var _prev_cam_fov: float = 75
var _cam_fov_changed: bool = false

var _prev_cam_size: float = 1
var _cam_size_changed: bool = false

var _prev_cam_frustum_offset: Vector2 = Vector2.ZERO
var _cam_frustum_offset_changed: bool = false

var _prev_cam_near: float = 0.05
var _cam_near_changed: bool = false

var _prev_cam_far: float = 4000
var _cam_far_changed: bool = false

#endregion

var _active_pcam_2d_glob_transform: Transform2D = Transform2D()
var _active_pcam_3d_glob_transform: Transform3D = Transform3D()

var _has_noise_emitted: bool = false
var _noise_emitted_output_2d: Transform2D = Transform2D()
var _noise_emitted_output_3d: Transform3D = Transform3D()

#endregion

# NOTE - Temp solution until Godot has better plugin autoload recognition out-of-the-box.
var _phantom_camera_manager: Node

#region Public Variables

## For 2D scenes, is the [Camera2D] instance the [param PhantomCameraHost] controls.
var camera_2d: Camera2D = null
## For 3D scenes, is the [Camera3D] instance the [param PhantomCameraHost] controls.
var camera_3d: Node = null ## Note: To support disable_3d export templates for 2D projects, this is purposely not strongly typed.

#endregion

#region Private Functions

## TBD - For when Godot 4.3 becomes a minimum version
#func _validate_property(property: Dictionary) -> void:
	#if property.name == \"interpolation_mode\" and get_parent() is Node3D:
		#property.usage = PROPERTY_USAGE_NO_EDITOR


func _get_configuration_warnings() -> PackedStringArray:
	var parent: Node = get_parent()

	if _is_2D:
		if not parent is Camera2D:
			return [\"Needs to be a child of a Camera2D in order to work.\"]
		else:
			return []
	else:
		if not parent.is_class(\"Camera3D\"): ## Note: To support disable_3d export templates for 2D projects, this is purposely not strongly typed.
			return [\"Needs to be a child of a Camera3D in order to work.\"]
		else:
			return []


func _enter_tree() -> void:
	_phantom_camera_manager = get_tree().root.get_node(_constants.PCAM_MANAGER_NODE_NAME)

	var parent: Node = get_parent()

	if parent is Camera2D or parent.is_class(\"Camera3D\"): ## Note: To support disable_3d export templates for 2D projects, this is purposely not strongly typed.
		_is_child_of_camera = true
		if parent is Camera2D:
			_is_2D = true
			camera_2d = parent
			## Force applies position smoothing to be disabled
			## This is to prevent overlap with the interpolation of the PCam2D.
			camera_2d.set_position_smoothing_enabled(false)
		else:
			_is_2D = false
			camera_3d = parent

		_phantom_camera_manager.pcam_host_added(self)
#		var already_multi_hosts: bool = multiple_pcam_hosts

		_check_camera_host_amount()

		if _multiple_pcam_hosts:
			printerr(
				\"Only one PhantomCameraHost can exist in a scene\",
				\"\\n\",
				\"Multiple PhantomCameraHosts will be supported in https://github.com/ramokz/phantom-camera/issues/26\"
			)
			queue_free()

		if _is_2D:
			if not _phantom_camera_manager.get_phantom_camera_2ds().is_empty():
				for pcam in _phantom_camera_manager.get_phantom_camera_2ds():
					pcam_added_to_scene(pcam)
					pcam.set_pcam_host_owner(self)
		else:
			if not _phantom_camera_manager.get_phantom_camera_3ds().is_empty():
				for pcam in _phantom_camera_manager.get_phantom_camera_3ds():
					pcam_added_to_scene(pcam)
					pcam.set_pcam_host_owner(self)


func _exit_tree() -> void:
	_phantom_camera_manager.pcam_host_removed(self)
	_check_camera_host_amount()


func _ready() -> void:
	process_priority = 300
	process_physics_priority = 300

	if _is_2D:
		camera_2d.offset = Vector2.ZERO
		if not is_instance_valid(_active_pcam_2d): return
		_active_pcam_2d_glob_transform = _active_pcam_2d.get_transform_output()
	else:
		if not is_instance_valid(_active_pcam_3d): return
		_active_pcam_3d_glob_transform = _active_pcam_3d.get_transform_output()


func _check_camera_host_amount() -> void:
	if _phantom_camera_manager.get_phantom_camera_hosts().size() > 1:
		_multiple_pcam_hosts = true
	else:
		_multiple_pcam_hosts = false


func _assign_new_active_pcam(pcam: Node) -> void:
	# Only checks if the scene tree is still present.
	# Prevents a few errors and checks from happening if the scene is exited.
	if not is_inside_tree(): return
	var no_previous_pcam: bool
	if is_instance_valid(_active_pcam_2d) or is_instance_valid(_active_pcam_3d):
		if _is_2D:
			_prev_active_pcam_2d_transform = camera_2d.global_transform
			_active_pcam_2d.queue_redraw()
			_active_pcam_2d.set_is_active(self, false)
			_active_pcam_2d.became_inactive.emit()

			if _active_pcam_2d.physics_target_changed.is_connected(_check_pcam_physics):
				_active_pcam_2d.physics_target_changed.disconnect(_check_pcam_physics)

			if _active_pcam_2d.noise_emitted.is_connected(_noise_emitted_2d):
				_active_pcam_2d.noise_emitted.disconnect(_noise_emitted_2d)

			if _trigger_pcam_tween:
				_active_pcam_2d.tween_interrupted.emit(pcam)
		else:
			_prev_active_pcam_3d_transform = camera_3d.global_transform
			_active_pcam_3d.set_is_active(self, false)
			_active_pcam_3d.became_inactive.emit()

			if _active_pcam_3d.physics_target_changed.is_connected(_check_pcam_physics):
				_active_pcam_3d.physics_target_changed.disconnect(_check_pcam_physics)

			if _active_pcam_3d.noise_emitted.is_connected(_noise_emitted_3d):
				_active_pcam_3d.noise_emitted.disconnect(_noise_emitted_3d)

			if _trigger_pcam_tween:
				_active_pcam_3d.tween_interrupted.emit(pcam)

			if camera_3d.attributes != null:
				var _attributes: CameraAttributes = camera_3d.attributes

				_prev_cam_exposure_multiplier = _attributes.exposure_multiplier
				_prev_cam_auto_exposure_scale = _attributes.auto_exposure_scale
				_prev_cam_auto_exposure_speed = _attributes.auto_exposure_speed

				if camera_3d.attributes is CameraAttributesPractical:
					_attributes = _attributes as CameraAttributesPractical

					_prev_cam_dof_blur_amount = _attributes.dof_blur_amount

					if _attributes.dof_blur_far_enabled:
						_prev_cam_dof_blur_far_distance = _attributes.dof_blur_far_distance
						_prev_cam_dof_blur_far_transition = _attributes.dof_blur_far_transition
					else:
						_prev_cam_dof_blur_far_distance = _cam_dof_blur_far_distance_default
						_prev_cam_dof_blur_far_transition = _cam_dof_blur_far_transition_default

					if _attributes.dof_blur_near_enabled:
						_prev_cam_dof_blur_near_distance = _attributes.dof_blur_near_distance
						_prev_cam_dof_blur_near_transition = _attributes.dof_blur_near_transition
					else:
						_prev_cam_dof_blur_near_distance = _cam_dof_blur_near_distance_default
						_prev_cam_dof_blur_near_transition = _cam_dof_blur_near_transition_default

					if _attributes.auto_exposure_enabled:
						_prev_cam_exposure_max_sensitivity = _attributes.auto_exposure_max_sensitivity
						_prev_cam_exposure_min_sensitivity = _attributes.auto_exposure_min_sensitivity

				elif camera_3d.attributes is CameraAttributesPhysical:
					_attributes = _attributes as CameraAttributesPhysical

					_prev_cam_frustum_focus_distance = _attributes.frustum_focus_distance
					_prev_cam_frustum_focal_length = _attributes.frustum_focal_length
					_prev_cam_frustum_far = _attributes.frustum_far
					_prev_cam_frustum_near = _attributes.frustum_near
					_prev_cam_exposure_aperture = _attributes.exposure_aperture
					_prev_cam_exposure_shutter_speed = _attributes.exposure_shutter_speed

					if _attributes.auto_exposure_enabled:
						_prev_cam_exposure_min_exposure_value = _attributes.auto_exposure_min_exposure_value
						_prev_cam_exposure_max_exposure_value = _attributes.auto_exposure_max_exposure_value

			_prev_cam_h_offset = camera_3d.h_offset
			_prev_cam_v_offset = camera_3d.v_offset
			_prev_cam_fov = camera_3d.fov
			_prev_cam_size = camera_3d.size
			_prev_cam_frustum_offset = camera_3d.frustum_offset
			_prev_cam_near = camera_3d.near
			_prev_cam_far = camera_3d.far

	else:
		no_previous_pcam = true

	## Assign newly active pcam
	if _is_2D:
		_active_pcam_2d = pcam
		_active_pcam_priority = _active_pcam_2d.priority
		_active_pcam_has_damping = _active_pcam_2d.follow_damping
		_tween_duration = _active_pcam_2d.tween_duration

		if not _active_pcam_2d.physics_target_changed.is_connected(_check_pcam_physics):
			_active_pcam_2d.physics_target_changed.connect(_check_pcam_physics)

		if not _active_pcam_2d.noise_emitted.is_connected(_noise_emitted_2d):
			_active_pcam_2d.noise_emitted.connect(_noise_emitted_2d)
	else:
		_active_pcam_3d = pcam
		_active_pcam_priority = _active_pcam_3d.priority
		_active_pcam_has_damping = _active_pcam_3d.follow_damping
		_tween_duration = _active_pcam_3d.tween_duration

		if not _active_pcam_3d.physics_target_changed.is_connected(_check_pcam_physics):
			_active_pcam_3d.physics_target_changed.connect(_check_pcam_physics)

		if not _active_pcam_3d.noise_emitted.is_connected(_noise_emitted_3d):
			_active_pcam_3d.noise_emitted.connect(_noise_emitted_3d)

		# Checks if the Camera3DResource has changed from the previous active PCam3D
		if _active_pcam_3d.camera_3d_resource:
			if _prev_cam_h_offset != _active_pcam_3d.h_offset:
				_cam_h_offset_changed = true
			if _prev_cam_v_offset != _active_pcam_3d.v_offset:
				_cam_v_offset_changed = true
			if _prev_cam_fov != _active_pcam_3d.fov:
				_cam_fov_changed = true
			if _prev_cam_size != _active_pcam_3d.size:
				_cam_size_changed = true
			if _prev_cam_frustum_offset != _active_pcam_3d.frustum_offset:
				_cam_frustum_offset_changed = true
			if _prev_cam_near != _active_pcam_3d.near:
				_cam_near_changed = true
			if _prev_cam_far != _active_pcam_3d.far:
				_cam_far_changed = true

		if _active_pcam_3d.attributes == null:
			_cam_attribute_changed = false
		else:
			if _prev_cam_attributes != _active_pcam_3d.attributes:
				_prev_cam_attributes = _active_pcam_3d.attributes
				_cam_attribute_changed = true
				var _attributes: CameraAttributes = _active_pcam_3d.attributes

				if _prev_cam_auto_exposure_scale != _attributes.auto_exposure_scale:
					_cam_auto_exposure_scale_changed = true
				if _prev_cam_auto_exposure_speed != _attributes.auto_exposure_speed:
					_cam_auto_exposure_speed_changed = true
				if _prev_cam_exposure_multiplier != _attributes.exposure_multiplier:
					_cam_exposure_multiplier_changed = true
				if _prev_cam_exposure_sensitivity != _attributes.exposure_sensitivity:
					_cam_exposure_sensitivity_changed = true

				if _attributes is CameraAttributesPractical:
					_cam_attribute_type = 0

					if camera_3d.attributes == null:
						camera_3d.attributes = CameraAttributesPractical.new()
						camera_3d.attributes = _active_pcam_3d.attributes.duplicate()
						_cam_attribute_assigned = true

					if _prev_cam_exposure_min_sensitivity != _attributes.auto_exposure_min_sensitivity:
						_cam_exposure_min_sensitivity_changed = true
					if _prev_cam_exposure_max_sensitivity != _attributes.auto_exposure_max_sensitivity:
						_cam_exposure_max_sensitivity_changed = true

					if _prev_cam_dof_blur_amount != _attributes.dof_blur_amount:
						_cam_dof_blur_amount_changed = true

					if _prev_cam_dof_blur_far_distance != _attributes.dof_blur_far_distance:
						_cam_dof_blur_far_distance_changed = true
						camera_3d.attributes.dof_blur_far_enabled = true
					if _prev_cam_dof_blur_far_transition != _attributes.dof_blur_far_transition:
						_cam_dof_blur_far_transition_changed = true
						camera_3d.attributes.dof_blur_far_enabled = true

					if _prev_cam_dof_blur_near_distance != _attributes.dof_blur_near_distance:
						_cam_dof_blur_near_distance_changed = true
						camera_3d.attributes.dof_blur_near_enabled = true
					if _prev_cam_dof_blur_near_transition != _attributes.dof_blur_near_transition:
						_cam_dof_blur_near_transition_changed = true
						camera_3d.attributes.dof_blur_near_enabled = true
				elif _attributes is CameraAttributesPhysical:
					_cam_attribute_type = 1

					if camera_3d.attributes == null:
						camera_3d.attributes = CameraAttributesPhysical.new()
						camera_3d.attributes = _active_pcam_3d.attributes.duplicate()

					if _prev_cam_exposure_min_exposure_value != _attributes.auto_exposure_min_exposure_value:
						_cam_exposure_min_exposure_value_changed = true
					if _prev_cam_exposure_max_exposure_value != _attributes.auto_exposure_max_exposure_value:
						_cam_exposure_max_exposure_value_changed = true

					if _prev_cam_exposure_aperture != _attributes.exposure_aperture:
						_cam_exposure_aperture_changed = true
					if _prev_cam_exposure_shutter_speed != _attributes.exposure_shutter_speed:
						_cam_exposure_shutter_speed_changed = true

					if _prev_cam_frustum_far != _attributes.frustum_far:
						_cam_frustum_far_changed = true

					if _prev_cam_frustum_focal_length != _attributes.frustum_focal_length:
						_cam_frustum_focal_length_changed = true

					if _prev_cam_frustum_focus_distance != _attributes.frustum_focus_distance:
						_cam_frustum_focus_distance_changed = true

					if _prev_cam_frustum_near != _attributes.frustum_near:
						_cam_frustum_near_changed = true

	if _is_2D:
		if _active_pcam_2d.show_viewfinder_in_play:
			_viewfinder_needed_check = true

		_active_pcam_2d.set_is_active(self, true)
		_active_pcam_2d.became_active.emit()
		_camera_zoom = camera_2d.zoom
	else:
		if _active_pcam_3d.show_viewfinder_in_play:
			_viewfinder_needed_check = true

		_active_pcam_3d.set_is_active(self, true)
		_active_pcam_3d.became_active.emit()
		if _active_pcam_3d.camera_3d_resource:
			camera_3d.cull_mask = _active_pcam_3d.cull_mask
			camera_3d.projection = _active_pcam_3d.projection

	if no_previous_pcam:
		if _is_2D:
			_prev_active_pcam_2d_transform = _active_pcam_2d.get_transform_output()
		else:
			_prev_active_pcam_3d_transform = _active_pcam_3d.get_transform_output()

	if pcam.get_tween_skip():
		_tween_elapsed_time = pcam.tween_duration
	else:
		_tween_elapsed_time = 0

	if pcam.tween_duration == 0:
		if Engine.get_version_info().major == 4 and \\
		Engine.get_version_info().minor >= 3:
			_tween_is_instant = true

	_check_pcam_physics()

	_trigger_pcam_tween = true


func _check_pcam_physics() -> void:
	if _is_2D:
		## NOTE - Only supported in Godot 4.3 or later
		if Engine.get_version_info().major == 4 and \\
		Engine.get_version_info().minor >= 3:
			if _active_pcam_2d.get_follow_target_physics_based():
				_follow_target_physics_based = true
				## TODO - Temporary solution to support Godot 4.2
				## Remove line below and uncomment the following once Godot 4.3 is min verison.
				camera_2d.call(\"reset_physics_interpolation\")
				camera_2d.set(\"physics_interpolation_mode\", 1)
				#camera_2d.reset_physics_interpolation()
				#camera_2d.physics_interpolation_mode = Node.PHYSICS_INTERPOLATION_MODE_ON
				if ProjectSettings.get_setting(\"physics/common/physics_interpolation\"):
					camera_2d.process_callback = Camera2D.CAMERA2D_PROCESS_PHYSICS # Prevents a warning
				else:
					camera_2d.process_callback = Camera2D.CAMERA2D_PROCESS_IDLE
			else:
				_follow_target_physics_based = false
				## TODO - Temporary solution to support Godot 4.2
				## Remove line below and uncomment the following once Godot 4.3 is min verison.
				camera_2d.set(\"physics_interpolation_mode\", 0)
				#camera_2d.physics_interpolation_mode = Node.PHYSICS_INTERPOLATION_MODE_INHERIT
				if get_tree().physics_interpolation:
					camera_2d.process_callback = Camera2D.CAMERA2D_PROCESS_PHYSICS # Prevents a warning
				else:
					camera_2d.process_callback = Camera2D.CAMERA2D_PROCESS_IDLE
	else:
		## NOTE - Only supported in Godot 4.4 or later
		if Engine.get_version_info().major == 4 and \\
		Engine.get_version_info().minor >= 4:
			if get_tree().physics_interpolation or _active_pcam_3d.get_follow_target_physics_based():
				#if get_tree().physics_interpolation or _active_pcam_3d.get_follow_target_physics_based():
				_follow_target_physics_based = true
				## TODO - Temporary solution to support Godot 4.2
				## Remove line below and uncomment the following once Godot 4.3 is min verison.
				camera_3d.call(\"reset_physics_interpolation\")
				camera_3d.set(\"physics_interpolation_mode\", 1)
				#camera_3d.reset_physics_interpolation()
				#camera_3d.physics_interpolation_mode = Node.PHYSICS_INTERPOLATION_MODE_ON
			else:
				_follow_target_physics_based = false
				## TODO - Temporary solution to support Godot 4.2
				## Remove line below and uncomment the following once Godot 4.3 is min verison.
				camera_3d.set(\"physics_interpolation_mode\", 0)


func _find_pcam_with_highest_priority() -> void:
	for pcam in _pcam_list:
		if not pcam.visible: continue # Prevents hidden PCams from becoming active
		if pcam.get_priority() > _active_pcam_priority:
			_assign_new_active_pcam(pcam)
		pcam.set_tween_skip(self, false)
		_active_pcam_missing = false


## TODO - For 0.8 release
#func _find_pcam_with_highest_priority() -> void:
	#var highest_priority_pcam: Node
	#for pcam in _pcam_list:
		#if not pcam.visible: continue # Prevents hidden PCams from becoming active
		#if pcam.priority > _active_pcam_priority:
			#_active_pcam_priority = pcam.priority
			#highest_priority_pcam = pcam
		#pcam.set_has_tweened(self, false)
#
		#_active_pcam_missing = false
#
	#if is_instance_valid(highest_priority_pcam):
		#_assign_new_active_pcam(highest_priority_pcam)
	#else:
		#_active_pcam_missing = true


func _process(delta: float) -> void:
	if _active_pcam_missing: return

	if not _follow_target_physics_based: _tween_follow_checker(delta)

	if not _has_noise_emitted: return
	if _is_2D:
		camera_2d.offset += _noise_emitted_output_2d.origin
		camera_2d.rotation += _noise_emitted_output_2d.get_rotation() # + _noise_emitted_output_2d.get_rotation()
	else:
		camera_3d.global_transform *= _noise_emitted_output_3d
	_has_noise_emitted = false


func _physics_process(delta: float) -> void:
	if _active_pcam_missing or not _follow_target_physics_based: return
	_tween_follow_checker(delta)


func _tween_follow_checker(delta: float) -> void:
	if _is_2D:
		_active_pcam_2d.process_logic(delta)
		_active_pcam_2d_glob_transform = _active_pcam_2d.get_transform_output()
	else:
		_active_pcam_3d.process_logic(delta)
		_active_pcam_3d_glob_transform = _active_pcam_3d.get_transform_output()

	if not _trigger_pcam_tween:
		# Rechecks physics target if PCam transitioned with an isntant tween
		if _tween_is_instant:
			_check_pcam_physics()
			_tween_is_instant = false
		_pcam_follow(delta)
	else:
		_pcam_tween(delta)

	if _is_2D:
		camera_2d.offset = Vector2.ZERO
		camera_2d.offset = _active_pcam_2d.get_noise_transform().origin # + _noise_emitted_output_2d.origin
		camera_2d.rotation += _active_pcam_2d.get_noise_transform().get_rotation() # + _noise_emitted_output_2d.get_rotation()
	else:
		camera_3d.global_transform *= _active_pcam_3d.get_noise_transform()


func _pcam_follow(_delta: float) -> void:
	if _is_2D:
		if not is_instance_valid(_active_pcam_2d): return
	else:
		if not is_instance_valid(_active_pcam_3d): return

	if _active_pcam_missing or not _is_child_of_camera: return

	if _is_2D:
		if _active_pcam_2d.snap_to_pixel:
			var snap_to_pixel_glob_transform: Transform2D = _active_pcam_2d_glob_transform
			snap_to_pixel_glob_transform.origin = snap_to_pixel_glob_transform.origin.round()
			camera_2d.global_transform = snap_to_pixel_glob_transform
		else:
			camera_2d.global_transform = _active_pcam_2d_glob_transform
		camera_2d.zoom = _active_pcam_2d.zoom
	else:
		camera_3d.global_transform = _active_pcam_3d_glob_transform

	if _viewfinder_needed_check:
		_show_viewfinder_in_play()
		_viewfinder_needed_check = false

	# TODO - Should be able to find a more efficient way using signals
	if Engine.is_editor_hint():
		if not _is_2D:
			if _active_pcam_3d.camera_3d_resource != null:
				camera_3d.cull_mask = _active_pcam_3d.cull_mask
				camera_3d.h_offset = _active_pcam_3d.h_offset
				camera_3d.v_offset = _active_pcam_3d.v_offset
				camera_3d.projection = _active_pcam_3d.projection
				camera_3d.fov = _active_pcam_3d.fov
				camera_3d.size = _active_pcam_3d.size
				camera_3d.frustum_offset = _active_pcam_3d.frustum_offset
				camera_3d.near = _active_pcam_3d.near
				camera_3d.far = _active_pcam_3d.far

			if _active_pcam_3d.attributes != null:
				camera_3d.attributes = _active_pcam_3d.attributes.duplicate()

			if _active_pcam_3d.environment != null:
				camera_3d.environment = _active_pcam_3d.environment.duplicate()


func _noise_emitted_2d(noise_output: Transform2D) -> void:
	_noise_emitted_output_2d = noise_output
	_has_noise_emitted = true


func _noise_emitted_3d(noise_output: Transform3D) -> void:
	_noise_emitted_output_3d = noise_output
	_has_noise_emitted = true


func _pcam_tween(delta: float) -> void:
	# Run at the first tween frame
	if _tween_elapsed_time == 0:
		if _is_2D:
			_active_pcam_2d.tween_started.emit()
			_active_pcam_2d.reset_limit()
		else:
			_active_pcam_3d.tween_started.emit()

	# Forcefully disables physics interpolation when tweens are instant
	if _tween_is_instant:
		if _is_2D:
			camera_2d.set(\"physics_interpolation_mode\", 2)
		else:
			camera_3d.set(\"physics_interpolation_mode\", 2)

	_tween_elapsed_time = min(_tween_duration, _tween_elapsed_time + delta)

	if _is_2D:
		_active_pcam_2d.is_tweening.emit()
		var interpolation_destination: Vector2 = _tween_interpolate_value(
			_prev_active_pcam_2d_transform.origin,
			_active_pcam_2d_glob_transform.origin,
			_active_pcam_2d.tween_duration,
			_active_pcam_2d.tween_transition,
			_active_pcam_2d.tween_ease
		)

		if _active_pcam_2d.snap_to_pixel:
			camera_2d.global_position = interpolation_destination.round()
		else:
			camera_2d.global_position = interpolation_destination

		camera_2d.rotation = _tween_interpolate_value(
			_prev_active_pcam_2d_transform.get_rotation(),
			_active_pcam_2d_glob_transform.get_rotation(),
			_active_pcam_2d.tween_duration,
			_active_pcam_2d.tween_transition,
			_active_pcam_2d.tween_ease
		)
		camera_2d.zoom = _tween_interpolate_value(
			_camera_zoom,
			_active_pcam_2d.zoom,
			_active_pcam_2d.tween_duration,
			_active_pcam_2d.tween_transition,
			_active_pcam_2d.tween_ease
		)
	else:
		_active_pcam_3d.is_tweening.emit()
		camera_3d.global_position = _tween_interpolate_value(
			_prev_active_pcam_3d_transform.origin,
			_active_pcam_3d_glob_transform.origin,
			_active_pcam_3d.tween_duration,
			_active_pcam_3d.tween_transition,
			_active_pcam_3d.tween_ease
		)

		var prev_active_pcam_3d_quat: Quaternion = Quaternion(_prev_active_pcam_3d_transform.basis.orthonormalized())
		camera_3d.quaternion = \\
			Tween.interpolate_value(
				prev_active_pcam_3d_quat, \\
				prev_active_pcam_3d_quat.inverse() * Quaternion(_active_pcam_3d_glob_transform.basis.orthonormalized()),
				_tween_elapsed_time, \\
				_active_pcam_3d.tween_duration, \\
				_active_pcam_3d.tween_transition,
				_active_pcam_3d.tween_ease
			)

		if _cam_attribute_changed:
			if _active_pcam_3d.attributes.auto_exposure_enabled:
				if _cam_auto_exposure_scale_changed:
					camera_3d.attributes.auto_exposure_scale = \\
						_tween_interpolate_value(
						_prev_cam_auto_exposure_scale,
						_active_pcam_3d.attributes.auto_exposure_scale,
						_active_pcam_3d.tween_duration,
						_active_pcam_3d.tween_transition,
						_active_pcam_3d.tween_ease
					)
				if _cam_auto_exposure_speed_changed:
					camera_3d.attributes.auto_exposure_speed = \\
						_tween_interpolate_value(
						_prev_cam_auto_exposure_scale,
						_active_pcam_3d.attributes.auto_exposure_scale,
						_active_pcam_3d.tween_duration,
						_active_pcam_3d.tween_transition,
						_active_pcam_3d.tween_ease
					)

			if _cam_attribute_type == 0: # CameraAttributePractical
				if _active_pcam_3d.attributes.auto_exposure_enabled:
					if _cam_exposure_min_sensitivity_changed:
						camera_3d.attributes.auto_exposure_min_sensitivity = \\
							_tween_interpolate_value(
							_prev_cam_exposure_min_sensitivity,
							_active_pcam_3d.attributes.auto_exposure_min_sensitivity,
							_active_pcam_3d.tween_duration,
							_active_pcam_3d.tween_transition,
							_active_pcam_3d.tween_ease
						)
					if _cam_exposure_max_sensitivity_changed:
						camera_3d.attributes.auto_exposure_max_sensitivity = \\
							_tween_interpolate_value(
							_prev_cam_exposure_max_sensitivity,
							_active_pcam_3d.attributes.auto_exposure_max_sensitivity,
							_active_pcam_3d.tween_duration,
							_active_pcam_3d.tween_transition,
							_active_pcam_3d.tween_ease
						)
				if _cam_dof_blur_amount_changed:
					camera_3d.attributes.dof_blur_amount = \\
						_tween_interpolate_value(
							_prev_cam_dof_blur_amount,
							_active_pcam_3d.attributes.dof_blur_amount,
							_active_pcam_3d.tween_duration,
							_active_pcam_3d.tween_transition,
							_active_pcam_3d.tween_ease
						)
				if _cam_dof_blur_far_distance_changed:
					camera_3d.attributes.dof_blur_far_distance = \\
						_tween_interpolate_value(
							_prev_cam_dof_blur_far_distance,
							_active_pcam_3d.attributes.dof_blur_far_distance,
							_active_pcam_3d.tween_duration,
							_active_pcam_3d.tween_transition,
							_active_pcam_3d.tween_ease
						)
				if _cam_dof_blur_far_transition_changed:
					camera_3d.attributes.dof_blur_far_transition = \\
						_tween_interpolate_value(
							_prev_cam_dof_blur_far_transition,
							_active_pcam_3d.attributes.dof_blur_far_transition,
							_active_pcam_3d.tween_duration,
							_active_pcam_3d.tween_transition,
							_active_pcam_3d.tween_ease
						)
				if _cam_dof_blur_near_distance_changed:
					camera_3d.attributes.dof_blur_near_distance = \\
						_tween_interpolate_value(
							_prev_cam_dof_blur_near_distance,
							_active_pcam_3d.attributes.dof_blur_near_distance,
							_active_pcam_3d.tween_duration,
							_active_pcam_3d.tween_transition,
							_active_pcam_3d.tween_ease
						)
				if _cam_dof_blur_near_transition_changed:
					camera_3d.attributes.dof_blur_near_transition = \\
						_tween_interpolate_value(
							_prev_cam_dof_blur_near_transition,
							_active_pcam_3d.attributes.dof_blur_near_transition,
							_active_pcam_3d.tween_duration,
							_active_pcam_3d.tween_transition,
							_active_pcam_3d.tween_ease
						)
			elif _cam_attribute_type == 1: # CameraAttributePhysical
				if _cam_dof_blur_near_transition_changed:
					camera_3d.attributes.auto_exposure_max_exposure_value = \\
						_tween_interpolate_value(
							_prev_cam_exposure_max_exposure_value,
							_active_pcam_3d.attributes.auto_exposure_max_exposure_value,
							_active_pcam_3d.tween_duration,
							_active_pcam_3d.tween_transition,
							_active_pcam_3d.tween_ease
						)
				if _cam_exposure_min_exposure_value_changed:
					camera_3d.attributes.auto_exposure_min_exposure_value = \\
						_tween_interpolate_value(
							_prev_cam_exposure_min_exposure_value,
							_active_pcam_3d.attributes.auto_exposure_min_exposure_value,
							_active_pcam_3d.tween_duration,
							_active_pcam_3d.tween_transition,
							_active_pcam_3d.tween_ease
						)
				if _cam_exposure_aperture_changed:
					camera_3d.attributes.exposure_aperture = \\
						_tween_interpolate_value(
							_prev_cam_exposure_aperture,
							_active_pcam_3d.attributes.exposure_aperture,
							_active_pcam_3d.tween_duration,
							_active_pcam_3d.tween_transition,
							_active_pcam_3d.tween_ease
						)
				if _cam_exposure_shutter_speed_changed:
					camera_3d.attributes.exposure_shutter_speed = \\
						_tween_interpolate_value(
							_prev_cam_exposure_shutter_speed,
							_active_pcam_3d.attributes.exposure_shutter_speed,
							_active_pcam_3d.tween_duration,
							_active_pcam_3d.tween_transition,
							_active_pcam_3d.tween_ease
						)
				if _cam_frustum_far_changed:
					camera_3d.attributes.frustum_far = \\
						_tween_interpolate_value(
							_prev_cam_frustum_far,
							_active_pcam_3d.attributes.frustum_far,
							_active_pcam_3d.tween_duration(),
							_active_pcam_3d.tween_transition(),
							_active_pcam_3d.tween_ease
						)
				if _cam_frustum_near_changed:
					camera_3d.attributes.frustum_near = \\
						_tween_interpolate_value(
							_prev_cam_frustum_far,
							_active_pcam_3d.attributes.frustum_near,
							_active_pcam_3d.tween_duration,
							_active_pcam_3d.tween_transition,
							_active_pcam_3d.tween_ease
						)
				if _cam_frustum_focal_length_changed:
					camera_3d.attributes.frustum_focal_length = \\
						_tween_interpolate_value(
							_prev_cam_frustum_focal_length,
							_active_pcam_3d.attributes.frustum_focal_length,
							_active_pcam_3d.tween_duration,
							_active_pcam_3d.tween_transition,
							_active_pcam_3d.tween_ease
						)
				if _cam_frustum_focus_distance_changed:
					camera_3d.attributes.frustum_focus_distance = \\
						_tween_interpolate_value(
							_prev_cam_frustum_focus_distance,
							_active_pcam_3d.attributes.frustum_focus_distance,
							_active_pcam_3d.tween_duration,
							_active_pcam_3d.tween_transition,
							_active_pcam_3d.tween_ease
						)

		if _cam_h_offset_changed:
			camera_3d.h_offset = \\
				_tween_interpolate_value(
					_prev_cam_h_offset,
					_active_pcam_3d.h_offset,
					_active_pcam_3d.tween_duration,
					_active_pcam_3d.tween_transition,
					_active_pcam_3d.tween_ease
				)

		if _cam_v_offset_changed:
			camera_3d.v_offset = \\
				_tween_interpolate_value(
					_prev_cam_v_offset,
					_active_pcam_3d.v_offset,
					_active_pcam_3d.tween_duration,
					_active_pcam_3d.tween_transition,
					_active_pcam_3d.tween_ease
				)

		if _cam_fov_changed:
			camera_3d.fov = \\
				_tween_interpolate_value(
					_prev_cam_fov,
					_active_pcam_3d.fov,
					_active_pcam_3d.tween_duration,
					_active_pcam_3d.tween_transition,
					_active_pcam_3d.tween_ease
				)

		if _cam_size_changed:
			camera_3d.size = \\
				_tween_interpolate_value(
					_prev_cam_size,
					_active_pcam_3d.size,
					_active_pcam_3d.tween_duration,
					_active_pcam_3d.tween_transition,
					_active_pcam_3d.tween_ease
				)

		if _cam_frustum_offset_changed:
			camera_3d.frustum_offset = \\
				_tween_interpolate_value(
					_prev_cam_frustum_offset,
					_active_pcam_3d.frustum_offset,
					_active_pcam_3d.tween_duration,
					_active_pcam_3d.tween_transition,
					_active_pcam_3d.tween_ease
				)


		if _cam_near_changed:
			camera_3d.near = \\
				_tween_interpolate_value(
					_prev_cam_near,
					_active_pcam_3d.near,
					_active_pcam_3d.tween_duration,
					_active_pcam_3d.tween_transition,
					_active_pcam_3d.tween_ease
				)

		if _cam_far_changed:
			camera_3d.far = \\
				_tween_interpolate_value(
					_prev_cam_far,
					_active_pcam_3d.far,
					_active_pcam_3d.tween_duration,
					_active_pcam_3d.tween_transition,
					_active_pcam_3d.tween_ease
				)

	if _tween_elapsed_time < _tween_duration: return
	_trigger_pcam_tween = false
	_tween_elapsed_time = 0
	if _is_2D:
		_active_pcam_2d.update_limit_all_sides()
		_active_pcam_2d.tween_completed.emit()
		if Engine.is_editor_hint():
			_active_pcam_2d.queue_redraw()
	else:
		if _active_pcam_3d.attributes != null:
			if _cam_attribute_type == 0:
				if not _active_pcam_3d.attributes.dof_blur_far_enabled:
					camera_3d.attributes.dof_blur_far_enabled = false
				if not _active_pcam_3d.attributes.dof_blur_near_enabled:
					camera_3d.attributes.dof_blur_near_enabled = false
		_cam_h_offset_changed = false
		_cam_v_offset_changed = false
		_cam_fov_changed = false
		_cam_size_changed = false
		_cam_frustum_offset_changed = false
		_cam_near_changed = false
		_cam_far_changed = false
		_cam_attribute_changed = false

		_active_pcam_3d.tween_completed.emit()


func _tween_interpolate_value(from: Variant, to: Variant, duration: float, transition_type: int, ease_type: int) -> Variant:
	return Tween.interpolate_value(
		from, \\
		to - from,
		_tween_elapsed_time, \\
		duration, \\
		transition_type,
		ease_type,
	)

func _show_viewfinder_in_play() -> void:
	# Don't show the viewfinder in the actual editor or project builds
	if Engine.is_editor_hint() or !OS.has_feature(\"editor\"): return

	# We default the viewfinder node to hidden
	if is_instance_valid(_viewfinder_node):
		_viewfinder_node.visible = false

	if _is_2D:
		if not _active_pcam_2d.show_viewfinder_in_play: return
		if _active_pcam_2d.follow_mode != _active_pcam_2d.FollowMode.FRAMED: return
	else:
		if not _active_pcam_3d.show_viewfinder_in_play: return
		if _active_pcam_3d.follow_mode != _active_pcam_2d.FollowMode.FRAMED: return

	var canvas_layer: CanvasLayer = CanvasLayer.new()
	get_tree().get_root().add_child(canvas_layer)

	# Instantiate the viewfinder scene if it isn't already
	if not is_instance_valid(_viewfinder_node):
		var _viewfinder_scene := load(\"res://addons/phantom_camera/panel/viewfinder/viewfinder_panel.tscn\")
		_viewfinder_node = _viewfinder_scene.instantiate()
		canvas_layer.add_child(_viewfinder_node)

	_viewfinder_node.visible = true
	_viewfinder_node.update_dead_zone()

#endregion

#region Public Functions

## Called when a [param PhantomCamera] is added to the scene.[br]
## [b]Note:[/b] This can only be called internally from a
## [param PhantomCamera] node.
func pcam_added_to_scene(pcam) -> void:
	if is_instance_of(pcam, PhantomCamera2D) or pcam.is_class(\"PhantomCamera3D\"): ## Note: To support disable_3d export templates for 2D projects, this is purposely not strongly typed.
		if not _pcam_list.has(pcam):
			_pcam_list.append(pcam)
			if not pcam.tween_on_load:
				pcam.set_tween_skip(self, true) # Skips its tween if it has the highest priority on load
			if not pcam.is_node_ready(): await pcam.ready
			_find_pcam_with_highest_priority()
	else:
		printerr(\"This function should only be called from PhantomCamera scripts\")


## Called when a [param PhantomCamera] is removed from the scene.[br]
## [b]Note:[/b] This can only be called internally from a
## [param PhantomCamera] node.
func pcam_removed_from_scene(pcam) -> void:
	if is_instance_of(pcam, PhantomCamera2D) or pcam.is_class(\"PhantomCamera3D\"): ## Note: To support disable_3d export templates for 2D projects, this is purposely not strongly typed.
		_pcam_list.erase(pcam)
		if _is_2D:
			if pcam == _active_pcam_2d:
				_active_pcam_missing = true
				_active_pcam_priority = -1
				_find_pcam_with_highest_priority()
		else:
			if pcam == _active_pcam_3d:
				_active_pcam_missing = true
				_active_pcam_priority = -1
				_find_pcam_with_highest_priority()
	else:
		printerr(\"This function should only be called from PhantomCamera scripts\")


## Triggers a recalculation to determine which PhantomCamera has the highest
## priority.
func pcam_priority_updated(pcam: Node) -> void:
	if Engine.is_editor_hint():
		if _is_2D:
			if _active_pcam_2d.priority_override: return
		else:
			if _active_pcam_3d.priority_override: return

	if not is_instance_valid(pcam): return

	var current_pcam_priority: int = pcam.priority

	if current_pcam_priority >= _active_pcam_priority:
		if _is_2D:
			if pcam != _active_pcam_2d:
				_assign_new_active_pcam(pcam)
		else:
			if pcam != _active_pcam_3d:
				_assign_new_active_pcam(pcam)

	if pcam == _active_pcam_2d or pcam == _active_pcam_3d:
		if current_pcam_priority <= _active_pcam_priority:
			_active_pcam_priority = current_pcam_priority
			_find_pcam_with_highest_priority()
		else:
			_active_pcam_priority = current_pcam_priority


## Updates the viewfinder when a [param PhantomCamera] has its
## [param priority_ovrride] enabled.[br]
## [b]Note:[/b] This only affects the editor.
func pcam_priority_override(pcam: Node) -> void:
	if Engine.is_editor_hint():
		if _is_2D:
			if _active_pcam_2d.priority_override:
				_active_pcam_2d.priority_override = false
		else:
			if _active_pcam_3d.priority_override:
				_active_pcam_3d.priority_override = false

	_assign_new_active_pcam(pcam)
	update_editor_viewfinder.emit()


## Updates the viewfinder when a [param PhantomCamera] has its
## [param priority_ovrride] disabled.[br]
## [b]Note:[/b] This only affects the editor.
func pcam_priority_override_disabled() -> void:
	update_editor_viewfinder.emit()


## Returns the currently active [param PhantomCamera]
func get_active_pcam() -> Node:
	if _is_2D:
		return _active_pcam_2d
	else:
		return _active_pcam_3d


## Returns whether if a [param PhantomCamera] should tween when it becomes
## active. If it's already active, the value will always be false.
## [b]Note:[/b] This can only be called internally from a
## [param PhantomCamera] node.
func get_trigger_pcam_tween() -> bool:
	return _trigger_pcam_tween


## Refreshes the [param PhantomCamera] list and checks for the highest priority. [br]
## [b]Note:[/b] This should [b]not[/b] be necessary to call manually.
func refresh_pcam_list_priorty() -> void:
	_active_pcam_priority = -1
	_find_pcam_with_highest_priority()


#func set_interpolation_mode(value: int) -> void:
	#interpolation_mode = value
#func get_interpolation_mode() -> int:
	#return interpolation_mode

#endregion
"

[node name="Level" type="Node2D"]
script = ExtResource("1_cy0xy")
LevelName = "Level1"

[node name="PhantomCamera" type="Node2D" parent="." node_paths=PackedStringArray("follow_target")]
top_level = true
position = Vector2(-73, 22)
script = SubResource("GDScript_oxieu")
follow_mode = 1
follow_target = NodePath("../Player")
zoom = Vector2(2, 2)
tween_resource = SubResource("Resource_rthbw")

[node name="Map" type="Node2D" parent="."]

[node name="TileMap" type="TileMapLayer" parent="Map"]
texture_filter = 1
tile_map_data = PackedByteArray("AAAAAP//AAADAAEAAAABAP//AAACAAUAAAAAAP7/AAADAAAAAAD///7/AAACAAAAAAD/////AAACAAEAAAD+/wAAAAAAAAIAAAD//wAAAAABAAIAAAAAAAAAAAADAAIAAAABAAAAAAACAAUAAAD9//7/AAACAAUAAAACAP//AAACAAUAAAACAAAAAAAAAAMAAAACAP3/AAAAAAEAAAABAP3/AAACAAUAAAD9//3/AAACAAUAAAD9////AAACAAUAAAD9/wAAAAACAAUAAAD+////AAABAAEAAAD+//7/AAABAAAAAAD+/wEAAAACAAUAAAD9/wEAAAACAAUAAAD//wEAAAACAAUAAAAAAAEAAAACAAUAAAABAAEAAAAAAAMAAAACAAEAAAACAAUAAAAAAPz/AAACAAUAAAD///z/AAACAAUAAAD9//z/AAABAAMAAAABAPz/AAACAAUAAAACAPz/AAAAAAAAAAADAAEAAAACAAUAAAADAAAAAAACAAUAAAADAP//AAACAAUAAAADAP3/AAACAAUAAAADAPz/AAACAAUAAAD8//z/AAACAAUAAAD8//3/AAACAAUAAAD8//7/AAACAAUAAAD8////AAACAAUAAAD8/wAAAAACAAUAAAD8/wEAAAACAAUAAAD8/wIAAAACAAUAAAD9/wIAAAACAAUAAAD+/wIAAAACAAUAAAD//wIAAAACAAUAAAAAAAIAAAACAAUAAAABAAIAAAACAAUAAAACAAIAAAACAAUAAAADAAIAAAACAAUAAAD7/wMAAAABAAYAAAD8/wMAAAACAAYAAAD9/wMAAAACAAYAAAD+/wMAAAACAAYAAAD//wMAAAACAAYAAAAAAAMAAAACAAYAAAABAAMAAAACAAYAAAACAAMAAAACAAYAAAADAAMAAAACAAYAAAAEAAMAAAADAAYAAAAEAAIAAAADAAUAAAAEAAEAAAAEAAQAAAAEAAAAAAACAAUAAAAEAP//AAACAAUAAAAEAP7/AAAEAAUAAAAEAP3/AAADAAUAAAAEAPz/AAADAAUAAAD7/wIAAAAFAAQAAAD7/wEAAAACAAUAAAD7/wAAAAACAAUAAAD7////AAAFAAUAAAD7//7/AAABAAUAAAD7//3/AAABAAUAAAD7//z/AAABAAUAAAD7//v/AAABAAQAAAAEAPv/AAADAAQAAAD8//v/AAACAAQAAAD9//v/AAACAAQAAAD+//v/AAACAAQAAAD///v/AAAFAAUAAAAAAPv/AAACAAUAAAABAPv/AAAEAAUAAAACAPv/AAACAAQAAAADAPv/AAACAAQAAAD6/wAAAAACAAUAAAD5/wAAAAACAAUAAAD4/wAAAAACAAUAAAD3/wAAAAACAAUAAAD2/wAAAAACAAUAAAD2/wEAAAACAAUAAAD3/wEAAAACAAUAAAD4/wEAAAACAAUAAAD5/wEAAAACAAUAAAD6/wEAAAACAAUAAAD6/wIAAAACAAYAAAD5/wIAAAACAAYAAAD4/wIAAAACAAYAAAD3/wIAAAACAAYAAAD2/wIAAAACAAYAAAD1/wIAAAABAAYAAAD1/wEAAAABAAUAAAD1/wAAAAABAAUAAAD1////AAABAAQAAAD2////AAACAAQAAAD3////AAACAAQAAAD6////AAACAAQAAAD+//z/AAADAAMAAAD+//3/AAACAAUAAAD///3/AAACAAUAAAAAAP3/AAACAAUAAAABAP7/AAACAAUAAAACAP7/AAAAAAIAAAADAP7/AAACAAUAAAAFAP//AAABAAAAAAAGAP//AAADAAMAAAAHAP7/AAACAAUAAAAIAP7/AAACAAUAAAAJAP7/AAACAAUAAAAKAP7/AAACAAUAAAAKAP3/AAACAAUAAAALAP3/AAACAAUAAAALAPz/AAACAAUAAAAMAPz/AAACAAUAAAAMAPv/AAACAAUAAAAMAPr/AAACAAUAAAANAPr/AAACAAUAAAANAPn/AAACAAUAAAANAPj/AAACAAUAAAANAPf/AAACAAUAAAAOAPf/AAACAAUAAAAOAPb/AAACAAUAAAAPAPb/AAACAAUAAAAQAPb/AAACAAUAAAARAPb/AAACAAUAAAARAPf/AAACAAUAAAASAPf/AAACAAUAAAATAPf/AAACAAUAAAATAPj/AAACAAUAAAAUAPj/AAACAAUAAAAVAPn/AAACAAUAAAAWAPr/AAACAAUAAAAWAPv/AAACAAUAAAAWAPz/AAACAAUAAAAWAP3/AAACAAUAAAAWAP7/AAACAAUAAAAWAP//AAACAAUAAAAVAP//AAACAAUAAAAVAAAAAAACAAUAAAAUAAAAAAACAAUAAAATAAEAAAACAAUAAAASAAEAAAACAAUAAAASAAAAAAACAAUAAAARAAAAAAAFAAQAAAARAP//AAACAAUAAAAQAP//AAAFAAQAAAAQAP7/AAACAAUAAAAPAP7/AAACAAUAAAAOAP7/AAACAAUAAAAOAP//AAAEAAQAAAANAP//AAACAAUAAAANAAAAAAAEAAQAAAAMAAAAAAACAAUAAAALAAAAAAACAAUAAAAKAAAAAAACAAUAAAAJAAAAAAACAAUAAAAIAAAAAAACAAUAAAAHAAAAAAACAAUAAAAGAAAAAAACAAUAAAAFAAAAAAAAAAIAAAAHAP//AAACAAUAAAAIAP//AAACAAUAAAAJAP//AAACAAUAAAAKAP//AAACAAUAAAALAP//AAACAAUAAAAMAP//AAACAAUAAAAMAP7/AAACAAUAAAAMAP3/AAACAAUAAAALAP7/AAACAAUAAAANAP3/AAACAAUAAAAOAP3/AAACAAUAAAANAP7/AAACAAUAAAANAPz/AAAAAAMAAAANAPv/AAACAAUAAAAOAPz/AAACAAUAAAAOAPv/AAACAAUAAAAOAPr/AAACAAUAAAAOAPn/AAACAAUAAAAOAPj/AAACAAUAAAAPAPf/AAACAAUAAAAQAPf/AAACAAUAAAARAPj/AAACAAUAAAAQAPj/AAACAAUAAAAQAPn/AAACAAAAAAAPAPn/AAABAAEAAAAPAPj/AAAAAAAAAAAPAPr/AAABAAIAAAAPAPv/AAACAAUAAAAPAPz/AAACAAUAAAAPAP3/AAACAAUAAAAQAP3/AAACAAUAAAAQAPz/AAACAAUAAAAQAPv/AAACAAUAAAAQAPr/AAACAAIAAAARAPn/AAADAAAAAAASAPj/AAACAAUAAAASAPn/AAACAAUAAAASAPr/AAACAAUAAAASAPv/AAAAAAAAAAARAPv/AAACAAUAAAARAPr/AAADAAIAAAARAPz/AAACAAUAAAARAP3/AAACAAUAAAARAP7/AAACAAUAAAASAP7/AAACAAUAAAASAP3/AAABAAIAAAASAPz/AAAAAAEAAAASAP//AAACAAUAAAATAAAAAAACAAUAAAATAP//AAACAAUAAAATAP7/AAACAAUAAAATAP3/AAADAAMAAAATAPz/AAACAAUAAAATAPv/AAACAAUAAAATAPr/AAACAAUAAAATAPn/AAACAAUAAAAUAPn/AAACAAUAAAAUAPr/AAACAAUAAAAUAPv/AAACAAUAAAAUAPz/AAACAAUAAAAUAP3/AAACAAUAAAAUAP7/AAACAAUAAAAUAP//AAACAAUAAAAVAP7/AAAAAAMAAAAVAP3/AAACAAUAAAAVAPz/AAACAAUAAAAVAPv/AAACAAUAAAAVAPr/AAACAAUAAAAFAAEAAAACAAYAAAAGAAEAAAACAAYAAAAHAAEAAAACAAYAAAAIAAEAAAACAAYAAAAJAAEAAAACAAYAAAAKAAEAAAACAAYAAAALAAEAAAACAAYAAAAMAAEAAAACAAYAAAANAAEAAAADAAYAAAASAAIAAAACAAYAAAATAAIAAAACAAYAAAAPAP//AAACAAYAAAAOAAAAAAADAAYAAAAQAAAAAAABAAYAAAARAAIAAAABAAYAAAARAAEAAAABAAUAAAAUAAIAAAADAAYAAAAWAAEAAAADAAYAAAAXAAAAAAADAAYAAAAVAAEAAAACAAYAAAAUAAEAAAAEAAQAAAAWAAAAAAAEAAQAAAAXAP//AAADAAUAAAAXAP7/AAADAAUAAAAXAP3/AAADAAUAAAAXAPz/AAADAAUAAAAXAPv/AAADAAUAAAAXAPr/AAADAAUAAAAWAPj/AAADAAQAAAAVAPf/AAADAAQAAAAWAPn/AAAEAAUAAAAXAPn/AAADAAQAAAAVAPj/AAAEAAUAAAAUAPb/AAADAAQAAAASAPX/AAADAAQAAAAUAPf/AAAEAAUAAAASAPb/AAAEAAUAAAATAPb/AAACAAQAAAARAPX/AAACAAQAAAAQAPX/AAACAAQAAAAPAPX/AAACAAQAAAAOAPX/AAACAAQAAAANAPX/AAABAAQAAAANAPb/AAAFAAUAAAAMAPb/AAABAAQAAAALAPn/AAABAAQAAAAKAPv/AAABAAQAAAAJAPz/AAABAAQAAAAGAP3/AAABAAQAAAAMAPn/AAAFAAUAAAALAPv/AAAFAAUAAAAKAPz/AAAFAAUAAAAHAP3/AAACAAQAAAAMAPf/AAABAAUAAAAMAPj/AAABAAUAAAALAPr/AAABAAUAAAAIAP3/AAACAAQAAAAJAP3/AAAFAAUAAAAGAP7/AAAFAAUAAAAFAP7/AAACAAQAAAD4////AAACAAQAAAD5////AAACAAQAAAAAAPr/AAACAAUAAAAAAPn/AAACAAUAAAAAAPj/AAACAAUAAAD///r/AAABAAUAAAD///n/AAABAAUAAAD///j/AAAFAAQAAAD///f/AAACAAUAAAD///b/AAACAAUAAAAAAPX/AAACAAUAAAABAPX/AAABAAMAAAABAPT/AAACAAUAAAACAPT/AAACAAUAAAADAPX/AAACAAMAAAADAPb/AAACAAUAAAADAPf/AAACAAUAAAACAPf/AAACAAUAAAABAPf/AAACAAUAAAAAAPf/AAACAAUAAAAAAPb/AAACAAUAAAACAPX/AAACAAMAAAACAPb/AAACAAUAAAABAPb/AAACAAUAAAD///X/AAACAAUAAAAAAPT/AAACAAUAAAAAAPP/AAACAAUAAAABAPP/AAABAAIAAAACAPP/AAACAAIAAAADAPP/AAADAAIAAAAEAPT/AAACAAUAAAAEAPX/AAADAAMAAAAEAPb/AAACAAUAAAABAPj/AAAEAAQAAAD+//b/AAACAAUAAAD+//X/AAACAAUAAAD+//T/AAACAAUAAAD///P/AAACAAUAAAACAPj/AAACAAYAAAD+//f/AAACAAUAAAADAPT/AAACAAUAAAAAAPL/AAACAAUAAAD///T/AAACAAUAAAACAPL/AAACAAEAAAABAPL/AAABAAEAAAABAPr/AAADAAUAAAABAPn/AAADAAUAAAADAPj/AAACAAYAAAAEAPj/AAACAAYAAAD+//j/AAACAAYAAAD9//j/AAACAAYAAAD8//j/AAABAAYAAAD8//f/AAABAAUAAAAFAPf/AAADAAUAAAAFAPj/AAADAAYAAAAGAPX/AAADAAUAAAAGAPb/AAADAAYAAAAHAPP/AAAEAAQAAAAHAPT/AAADAAYAAAAIAPL/AAADAAUAAAAIAPP/AAADAAYAAAAIAPD/AAADAAQAAAAIAPH/AAADAAUAAAAGAPT/AAAEAAQAAAAFAPb/AAAEAAQAAAAEAPf/AAACAAUAAAD8//b/AAABAAUAAAD7//X/AAACAAYAAAD6//T/AAABAAUAAAD6//P/AAABAAUAAAD7//L/AAACAAUAAAD7//H/AAACAAQAAAD+/+//AAACAAQAAAD//+//AAACAAQAAAAAAO//AAACAAQAAAABAO//AAACAAQAAAACAO//AAAFAAUAAAADAO//AAACAAUAAAAEAO//AAABAAAAAAAFAO//AAADAAAAAAAGAO//AAAEAAUAAAD9/+//AAABAAQAAAAHAO//AAADAAQAAAD8//D/AAABAAQAAAD7//P/AAACAAUAAAD8//H/AAAFAAUAAAD9//D/AAAFAAUAAAD7//T/AAACAAUAAAD8//T/AAAAAAMAAAD8//X/AAAFAAQAAAD9//H/AAACAAUAAAD9//L/AAAAAAMAAAD8//L/AAACAAUAAAD8//P/AAACAAUAAAD9//P/AAACAAUAAAD9//T/AAACAAUAAAD9//X/AAACAAUAAAD9//b/AAACAAUAAAD9//f/AAACAAUAAAD+//P/AAACAAUAAAD+//L/AAACAAUAAAD+//H/AAACAAUAAAD+//D/AAACAAUAAAD///D/AAACAAUAAAD///H/AAACAAUAAAD///L/AAACAAUAAAAAAPH/AAACAAUAAAAAAPD/AAACAAUAAAABAPD/AAACAAUAAAABAPH/AAABAAAAAAACAPH/AAACAAAAAAACAPD/AAACAAUAAAADAPD/AAABAAAAAAADAPH/AAAEAAIAAAADAPL/AAADAAEAAAAEAPL/AAACAAUAAAAEAPH/AAADAAIAAAAEAPD/AAAEAAIAAAAFAPD/AAADAAIAAAAFAPH/AAACAAUAAAAFAPL/AAACAAUAAAAFAPP/AAACAAUAAAAEAPP/AAACAAUAAAAFAPT/AAACAAUAAAAFAPX/AAACAAUAAAAGAPP/AAACAAUAAAAGAPL/AAACAAUAAAAGAPH/AAACAAUAAAAGAPD/AAACAAUAAAAHAPD/AAACAAUAAAAHAPH/AAAAAAMAAAAHAPL/AAACAAUAAAADAO7/AAACAAQAAAACAO7/AAABAAQAAAAEAO7/AAACAAQAAAAFAO7/AAACAAQAAAAGAO7/AAADAAQAAAD1/wMAAAAEAAMAAAD2/wMAAAAEAAMAAAD3/wMAAAAEAAMAAAD4/wMAAAAEAAMAAAD5/wMAAAAEAAMAAAD6/wMAAAAEAAMAAAD7/wQAAAAEAAMAAAD8/wQAAAAEAAMAAAD9/wQAAAAEAAMAAAD+/wQAAAAEAAMAAAD//wQAAAAEAAMAAAAAAAQAAAAEAAMAAAABAAQAAAAEAAMAAAACAAQAAAAEAAMAAAADAAQAAAAEAAMAAAAEAAQAAAAEAAMAAAAFAAQAAAAEAAMAAAAFAAMAAAAEAAMAAAAFAAIAAAAEAAMAAAAGAAIAAAAEAAMAAAAHAAIAAAAEAAMAAAAIAAIAAAAEAAMAAAAJAAIAAAAEAAMAAAAKAAIAAAAEAAMAAAALAAIAAAAEAAMAAAAMAAIAAAAEAAMAAAANAAIAAAAEAAMAAAAOAAIAAAAEAAMAAAAOAAEAAAAEAAMAAAAPAAEAAAAEAAMAAAAPAAAAAAAEAAMAAAAQAAEAAAAEAAMAAAAQAAIAAAAEAAMAAAAQAAMAAAAEAAMAAAARAAMAAAAEAAMAAAASAAMAAAAEAAMAAAATAAMAAAAEAAMAAAAUAAMAAAAEAAMAAAAVAAMAAAAEAAMAAAAVAAIAAAAEAAMAAAAWAAIAAAAEAAMAAAAXAAIAAAAEAAMAAAAXAAEAAAAEAAMAAAAYAAEAAAAEAAMAAAAYAAAAAAAEAAMAAAAYAP//AAAEAAMAAAAYAP7/AAAEAAMAAAAYAP3/AAAEAAMAAAAYAPz/AAAEAAMAAAAYAPv/AAAEAAMAAAAYAPr/AAAEAAMAAAAYAPn/AAAEAAMAAAAYAPj/AAAEAAMAAAAXAPj/AAAEAAMAAAAXAPf/AAAEAAMAAAAWAPf/AAAEAAMAAAAWAPb/AAAEAAMAAAAVAPb/AAAEAAMAAAAVAPX/AAAEAAMAAAAUAPX/AAAEAAMAAAATAPX/AAAEAAMAAAATAPT/AAAEAAMAAAASAPT/AAAEAAMAAAARAPT/AAAEAAMAAAAQAPT/AAAEAAMAAAAPAPT/AAAEAAMAAAAOAPT/AAAEAAMAAAANAPT/AAAEAAMAAAAMAPT/AAAEAAMAAAAMAPX/AAAEAAMAAAALAPX/AAAEAAMAAAALAPb/AAAEAAMAAAALAPf/AAAEAAMAAAALAPj/AAAEAAMAAAAKAPj/AAAEAAMAAAAKAPn/AAAEAAMAAAAKAPr/AAAEAAMAAAAJAPr/AAAEAAMAAAAJAPv/AAAEAAMAAAAIAPv/AAAEAAMAAAAIAPz/AAAEAAMAAAAHAPz/AAAEAAMAAAAGAPz/AAAEAAMAAAAFAPz/AAAEAAMAAAAFAP3/AAAEAAMAAAAFAPv/AAAEAAMAAAAFAPr/AAAEAAMAAAAEAPr/AAAEAAMAAAADAPr/AAAEAAMAAAACAPr/AAAEAAMAAAACAPn/AAAEAAMAAAD0/wMAAAAEAAMAAAD0/wIAAAAEAAMAAAD3//7/AAAEAAMAAAD4//7/AAAEAAMAAAD5//7/AAAEAAMAAAD6//7/AAAEAAMAAAD0/wEAAAAEAAMAAAD0/wAAAAAEAAMAAAD0////AAAEAAMAAAD0//7/AAAEAAMAAAD1//7/AAAEAAMAAAD2//7/AAAEAAMAAAD+//n/AAAEAAMAAAD+//r/AAAEAAMAAAD6//L/AAABAAUAAAD6//X/AAABAAYAAAD6//H/AAABAAQAAAAGAAMAAAAEAAMAAAAHAAMAAAAEAAMAAAAIAAMAAAAEAAMAAAAMAAMAAAAEAAMAAAANAAMAAAAEAAMAAAAOAAMAAAAEAAMAAAAPAAMAAAAEAAMAAAAMAAQAAAAEAAMAAAALAAQAAAAEAAMAAAAKAAQAAAAEAAMAAAAJAAQAAAAEAAMAAAAJAAMAAAAEAAMAAAAKAAMAAAAEAAMAAAALAAMAAAAEAAMAAAAPAAIAAAAEAAMAAAAWAAMAAAAEAAMAAAAXAAMAAAAEAAMAAAD1//3/AAAEAAMAAAD2//3/AAAEAAMAAAD6//3/AAAEAAMAAAD5//3/AAAEAAMAAAD4//3/AAAEAAMAAAD3//3/AAAEAAMAAAD5//z/AAAEAAMAAAD6//z/AAAEAAMAAAD4//z/AAAEAAMAAAD3//z/AAAEAAMAAAD2//v/AAAEAAMAAAD1//v/AAAEAAMAAAD3//v/AAAEAAMAAAD4//v/AAAEAAMAAAD5//v/AAAEAAMAAAD3//r/AAAEAAMAAAD2//r/AAAEAAMAAAD4//r/AAAEAAMAAAD5//r/AAAEAAMAAAD6//r/AAAEAAMAAAD7//r/AAAEAAMAAAD8//r/AAAEAAMAAAD9//r/AAAEAAMAAAD9//n/AAAEAAMAAAD8//n/AAAEAAMAAAD7//n/AAAEAAMAAAD7//j/AAAEAAMAAAD7//f/AAAEAAMAAAD6//f/AAAEAAMAAAD6//b/AAAEAAMAAAD5//b/AAAEAAMAAAD4//b/AAAEAAMAAAD3//f/AAAEAAMAAAD2//f/AAAEAAMAAAD4//f/AAAEAAMAAAD3//b/AAAEAAMAAAD2//b/AAAEAAMAAAD1//b/AAAEAAMAAAD0//b/AAAEAAMAAAD0//f/AAAEAAMAAAD1//f/AAAEAAMAAAD5//j/AAAEAAMAAAD5//n/AAAEAAMAAAD4//n/AAAEAAMAAAD3//n/AAAEAAMAAAD2//n/AAAEAAMAAAD2//z/AAAEAAMAAAD4//j/AAAEAAMAAAD3//X/AAAEAAMAAAD4//X/AAAEAAMAAAD2//X/AAAEAAMAAAD1//X/AAAEAAMAAAD1//T/AAAEAAMAAAD2//T/AAAEAAMAAAD3//T/AAAEAAMAAAD4//T/AAAEAAMAAAD3//P/AAAEAAMAAAD2//P/AAAEAAMAAAD1//P/AAAEAAMAAAD4//P/AAAEAAMAAAD4//L/AAAEAAMAAAD3//L/AAAEAAMAAAD2//L/AAAEAAMAAAD4//H/AAAEAAMAAAD3//H/AAAEAAMAAAD5//H/AAAEAAMAAAD5//D/AAAEAAMAAAD4//D/AAAEAAMAAAD3//D/AAAEAAMAAAD2//D/AAAEAAMAAAD1//D/AAAEAAMAAAD1/+//AAAEAAMAAAD2/+//AAAEAAMAAAD3/+//AAAEAAMAAAD1/+7/AAAEAAMAAAD2/+7/AAAEAAMAAAD3/+7/AAAEAAMAAAD4/+7/AAAEAAMAAAD5/+7/AAAEAAMAAAD6/+7/AAAEAAMAAAD7/+7/AAAEAAMAAAD8/+7/AAAEAAMAAAD9/+7/AAAEAAMAAAD+/+7/AAAEAAMAAAD//+7/AAAEAAMAAAAAAO7/AAAEAAMAAAABAO7/AAAEAAMAAAD8/+//AAAEAAMAAAD7/+//AAAEAAMAAAD6/+//AAAEAAMAAAD5/+//AAAEAAMAAAD4/+//AAAEAAMAAAD6//D/AAAEAAMAAAD7//D/AAAEAAMAAAD6//j/AAAEAAMAAAD6//n/AAAEAAMAAAD6//v/AAAEAAMAAAD7//b/AAAEAAMAAAD5//f/AAAEAAMAAAD3//j/AAAEAAMAAAD2//j/AAAEAAMAAAD1//j/AAAEAAMAAAD0//j/AAAEAAMAAAD0//n/AAAEAAMAAADz//n/AAAEAAMAAAD1//n/AAAEAAMAAAD1//r/AAAEAAMAAAD0//r/AAAEAAMAAAD1//z/AAAEAAMAAAD5//X/AAAEAAMAAAD5//T/AAAEAAMAAAD5//P/AAAEAAMAAAD5//L/AAAEAAMAAAD2//H/AAAEAAMAAAD1//H/AAAEAAMAAAD1//L/AAAEAAMAAAADAPn/AAAEAAMAAAAEAPn/AAAEAAMAAAAFAPn/AAAEAAMAAAAGAPn/AAAEAAMAAAAHAPn/AAAEAAMAAAAIAPn/AAAEAAMAAAAJAPn/AAAEAAMAAAAGAPr/AAAEAAMAAAAHAPr/AAAEAAMAAAAIAPr/AAAEAAMAAAAGAPv/AAAEAAMAAAAHAPv/AAAEAAMAAAAGAPj/AAAEAAMAAAAGAPf/AAAEAAMAAAAHAPf/AAAEAAMAAAAIAPf/AAAEAAMAAAAJAPf/AAAEAAMAAAAKAPf/AAAEAAMAAAAJAPj/AAAEAAMAAAAIAPj/AAAEAAMAAAAHAPj/AAAEAAMAAAAHAPb/AAAEAAMAAAAHAPX/AAAEAAMAAAAIAPX/AAAEAAMAAAAJAPX/AAAEAAMAAAAKAPX/AAAEAAMAAAAKAPb/AAAEAAMAAAAJAPb/AAAEAAMAAAAIAPb/AAAEAAMAAAAIAPT/AAAEAAMAAAAJAPT/AAAEAAMAAAAKAPT/AAAEAAMAAAALAPT/AAAEAAMAAAALAPP/AAAEAAMAAAALAPL/AAAEAAMAAAALAPH/AAAEAAMAAAALAPD/AAAEAAMAAAALAO//AAAEAAMAAAALAO7/AAAEAAMAAAAKAPL/AAAEAAMAAAAKAPP/AAAEAAMAAAAJAPP/AAAEAAMAAAAJAPL/AAAEAAMAAAAJAPH/AAAEAAMAAAAJAPD/AAAEAAMAAAAJAO//AAAEAAMAAAAIAO//AAAEAAMAAAAIAO7/AAAEAAMAAAAHAO7/AAAEAAMAAAAJAO7/AAAEAAMAAAAKAO7/AAAEAAMAAAAMAO7/AAAEAAMAAAANAO7/AAAEAAMAAAAOAO7/AAAEAAMAAAAPAO7/AAAEAAMAAAAQAO7/AAAEAAMAAAARAO7/AAAEAAMAAAASAO7/AAAEAAMAAAATAO7/AAAEAAMAAAAUAO7/AAAEAAMAAAAVAO7/AAAEAAMAAAAWAO7/AAAEAAMAAAAXAO7/AAAEAAMAAAAXAO//AAAEAAMAAAAXAPD/AAAEAAMAAAAXAPH/AAAEAAMAAAAXAPL/AAAEAAMAAAAXAPP/AAAEAAMAAAAXAPT/AAAEAAMAAAAXAPX/AAAEAAMAAAAXAPb/AAAEAAMAAAAWAPX/AAAEAAMAAAAWAPT/AAAEAAMAAAAWAPP/AAAEAAMAAAAWAPL/AAAEAAMAAAAWAPH/AAAEAAMAAAAWAPD/AAAEAAMAAAAVAPD/AAAEAAMAAAAUAO//AAAEAAMAAAATAO//AAAEAAMAAAASAO//AAAEAAMAAAARAO//AAAEAAMAAAAQAO//AAAEAAMAAAAPAO//AAAEAAMAAAAOAO//AAAEAAMAAAANAO//AAAEAAMAAAAMAO//AAAEAAMAAAAOAPD/AAAEAAMAAAAPAPD/AAAEAAMAAAAQAPD/AAAEAAMAAAARAPD/AAAEAAMAAAASAPD/AAAEAAMAAAATAPD/AAAEAAMAAAAUAPD/AAAEAAMAAAAUAPH/AAAEAAMAAAATAPH/AAAEAAMAAAASAPH/AAAEAAMAAAARAPH/AAAEAAMAAAAQAPH/AAAEAAMAAAAPAPH/AAAEAAMAAAAOAPH/AAAEAAMAAAANAPH/AAAEAAMAAAAMAPH/AAAEAAMAAAAVAPH/AAAEAAMAAAATAPL/AAAEAAMAAAASAPL/AAAEAAMAAAARAPL/AAAEAAMAAAAQAPL/AAAEAAMAAAAPAPL/AAAEAAMAAAAOAPL/AAAEAAMAAAANAPL/AAAEAAMAAAAMAPL/AAAEAAMAAAATAPP/AAAEAAMAAAAUAPP/AAAEAAMAAAAVAPP/AAAEAAMAAAASAPP/AAAEAAMAAAARAPP/AAAEAAMAAAAQAPP/AAAEAAMAAAAPAPP/AAAEAAMAAAAOAPP/AAAEAAMAAAANAPP/AAAEAAMAAAAMAPP/AAAEAAMAAAAVAPT/AAAEAAMAAAAUAPT/AAAEAAMAAAAKAO//AAAEAAMAAAAKAPD/AAAEAAMAAAAKAPH/AAAEAAMAAAANAPD/AAAEAAMAAAAMAPD/AAAEAAMAAAAUAPL/AAAEAAMAAAAVAPL/AAAEAAMAAAAVAO//AAAEAAMAAAAWAO//AAAEAAMAAAA=")
tile_set = SubResource("TileSet_3qvaf")

[node name="TileMap2" type="TileMapLayer" parent="Map"]
visibility_layer = 2
texture_filter = 1
tile_map_data = PackedByteArray("AAD8//H/AQAAAAMAAAD8//T/AQAAAAMAAAA=")
tile_set = SubResource("TileSet_3qvaf")

[node name="OutlineMap" type="TileMapLayer" parent="Map"]
tile_map_data = PackedByteArray("AAB8AHsAAAAAAAAAAAB/AHsAAAAAAAAAAAB/AH0AAAAAAAAAAAB8AH4AAAAAAAAAAAB/AH8AAAAAAAAAAAB/AH4AAAAAAAAAAAA=")
tile_set = SubResource("TileSet_ol3dr")

[node name="Backdrop" type="ColorRect" parent="Map"]
show_behind_parent = true
texture_repeat = 3
offset_left = -5882.0
offset_top = -2820.0
offset_right = -4582.0
offset_bottom = -2120.0
scale = Vector2(10, 10)
color = Color(0, 0, 0, 1)

[node name="NavigationRegion2D" type="NavigationRegion2D" parent="Map"]
navigation_polygon = SubResource("NavigationPolygon_aqjx3")

[node name="Misc" type="Node2D" parent="."]

[node name="MovingSprite" type="Sprite2D" parent="Misc"]
visible = false
texture = SubResource("AtlasTexture_4d2lx")

[node name="OverworldCamera" type="Camera2D" parent="Misc"]
physics_interpolation_mode = 1
position = Vector2(-73, 22)
zoom = Vector2(2, 2)
process_callback = 0

[node name="PhantomCameraHost" type="Node" parent="Misc/OverworldCamera"]
process_priority = 300
process_physics_priority = 300
script = SubResource("GDScript_8kgpg")

[node name="UI" parent="Misc/OverworldCamera" instance=ExtResource("8_yw6rv")]
texture_filter = 1
anchors_preset = 0
anchor_right = 0.0
anchor_bottom = 0.0
grow_horizontal = 1
grow_vertical = 1

[node name="Npcs" type="Node2D" parent="."]

[node name="Corvi" parent="Npcs" instance=ExtResource("13_vtoc5")]
position = Vector2(120, -641)

[node name="Amogus" parent="Npcs" instance=ExtResource("14_k74xa")]
position = Vector2(-442, 20)
DisplayPortraitRim = ExtResource("11_6mk6w")

[node name="Amogus2" parent="Npcs" instance=ExtResource("14_k74xa")]
position = Vector2(-24, -24)
DisplayPortraitRim = ExtResource("11_6mk6w")

[node name="Amogus3" parent="Npcs" instance=ExtResource("14_k74xa")]
position = Vector2(24, 24)
DisplayPortraitRim = ExtResource("11_6mk6w")

[node name="Amogus4" parent="Npcs" instance=ExtResource("14_k74xa")]
position = Vector2(24, -24)
DisplayPortraitRim = ExtResource("11_6mk6w")

[node name="Amogus5" parent="Npcs" instance=ExtResource("14_k74xa")]
position = Vector2(-24, 24)
DisplayPortraitRim = ExtResource("11_6mk6w")

[node name="Triggers" type="Node2D" parent="."]

[node name="DialogueTrigger" parent="Triggers" instance=ExtResource("12_x6p1d")]
position = Vector2(-200, 0)
scale = Vector2(3, 3)
Timeline = "wake_up"

[node name="CombarTrigger" parent="Triggers" instance=ExtResource("11_gtgde")]
position = Vector2(248, 2)
scale = Vector2(1, 10)

[node name="Area2D" parent="Triggers" instance=ExtResource("11_itbd5")]
position = Vector2(-192, -610)
scale = Vector2(1, 10)
Destination = "res://Scenes/Levels/Level2.tscn"

[node name="Objs" type="Node2D" parent="."]

[node name="Sign_1_1" parent="Objs" instance=ExtResource("9_7ui60")]
position = Vector2(-185, -190)
DisplayName = "Sign_1_1"

[node name="Player" parent="." instance=ExtResource("12_6myqq")]
position = Vector2(-73, 22)
IsAutoamted = false
DisplayName = "Roi"
DisplaySprite = ExtResource("15_kxo26")
DisplayPortrait = ExtResource("16_7kn55")
DisplayPortraitRim = ExtResource("6_kwc70")

[connection signal="body_entered" from="Triggers/DialogueTrigger" to="Triggers/DialogueTrigger" method="_on_body_entered"]
